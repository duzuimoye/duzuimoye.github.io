<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[问卷调查]]></title>
    <url>%2Fduzuimoye.github.io%2F2020%2F06%2F22%2FquestionNaire%2F</url>
    <content type="text"><![CDATA[前言最近pm问我能不能做类似于腾讯问卷星一样的问卷调查功能？就是pc端这边配置问卷，app用户填写，填写完保存可以查看自己的问卷信息。一开始本着自己的职业操守说：我先看看腾讯问卷星是怎么实现的，到时再给你答复。研究了一下感觉能做。就答应下来了。过几天设计稿下来了就开始动手做了。幸不辱命结果还是做出来了。话不多说，先看看效果吧。 1：pc问卷配置页第一版我们的问卷配置页只有单选题，多选题和填空题。目前是左边点击一下题目类型，右边页面就会生成对应的体型。大概配置页面如下：简单说一下各种题型 填空题（其实页面和逻辑比较简单，我就一笔带过了） 单选题（单选题也就多了个选项说明和分数，以及操作按钮换位置或者删除当前选项） 多选题 （基本跟单选一样 不过用户可以选择多个选项） 2：pc问卷配置页特殊跳转问题目前我们支持3种跳转方式来满足不同用户的需求，跳转指定页和按选项跳转页面以及定制方案（为特殊用户提供定制方案从而推销自己的产品，当然这种是要另外收钱的） 目前问卷调查配置页已完成，用户可以根据自己的要求来配置问卷。配置好问卷之后，用户可以在app来作答完成问卷。 3:app问卷pc配置页出来之后 app填写，大概页面如下。 4:遇到的问题在做没有特殊跳转的问卷时候，写的一帆风顺，但做特殊页面调整的时候，当时卡住了，比如说用户从第三页跳到第六页，我怎么让Ta从第六页回到第三页而不是第五页，因为我这一开始是根据下标去判断是问卷的第几页的。当时纠结了一下，后来用一个数组记录了下标，通过上一步下一步去维护这个像栈一样的数组。上一步下一步的相关代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748if(step === 1) &#123; for (let question of this.currentPage &amp;&amp; this.currentPage.questionList) &#123; let flag = false let isRequired = false if (question.optionList) &#123; for (let optionItem of question.optionList) &#123; if (optionItem.checked) &#123; flag = true &#125; if (optionItem.ifRequired) &#123; isRequired = true &#125; &#125; &#125; if (!question.optionId &amp;&amp; !flag &amp;&amp; isRequired) &#123; Toast.start(&#123; info: &apos;请填完所有的选项&apos;, type: &apos;error&apos;, time: 1500 &#125;) return false &#125; &#125; if (this.currentSteps === this.MaxPageCount || this.currentPage.pageRedirectType === &apos;CUSTOM_CONTENT&apos;) &#123; this.save() return false &#125; if (this.currentPage.pageRedirectType === &apos;CUSTOM_OPTION&apos;) &#123; for (let [index, pageItem] of this.questionPageList.entries()) &#123; if (this.pageId === pageItem.pageId) &#123; this.currentSteps = index return false &#125; &#125; &#125; if(this.currentPage.pageRedirectType === &apos;CUSTOM_PAGE&apos;) &#123; for (let [index, pageItem] of this.questionPageList.entries()) &#123; if (this.currentPage.pageRedirectPageId === pageItem.pageId) &#123; this.currentSteps = index return false &#125; &#125; &#125; this.currentSteps = this.currentSteps + 1&#125; else &#123; this.stepsArr = this.stepsArr.slice(0, -1) this.currentSteps = this.stepsArr.pop()&#125; 总结这个问卷需求做下来，其实有一些自己没有考虑好。当初技术讨论的时候，我们leader问我问卷是一页一页提交还是一起提交，当时脑子瓦特了没考虑那么多，就选了一起提交。毕业也有一年了，希望自己不要盲目自信，多总结经验，多沉淀自己的技术。多向大佬学习。另外码字不容易，希望大家点个赞。前端路漫漫，与君共勉之。]]></content>
      <tags>
        <tag>问卷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信扫码登录]]></title>
    <url>%2Fduzuimoye.github.io%2F2020%2F03%2F29%2FwechatLogin%2F</url>
    <content type="text"><![CDATA[前言最近leader给了我一个需求，让我微信扫码登录我们的pc系统。一开始拿到这个需求，看了二三次微信官方文档之后，本以为会很简单，半天之内就能搞定。直接奥利给，撸代码。结果啪啪啪打脸，把所有的坑都踩过了。不过幸不辱命，还是把这个需求写完了。 1:准备工作网站应用微信登录是基于OAuth2.0协议标准构建的微信OAuth2.0授权登录系统。 在进行微信OAuth2.0授权登录接入之前，在微信开放平台注册开发者帐号，并拥有一个已审核通过的网站应用，并获得相应的AppID和AppSecret，申请微信登录且通过审核后，可开始接入流程。审核大概要一周时间外加300rmb。微信官方文档 2:整理思路审核通过之后整理整个需求思路。大概画了这样一个流程图。 3:所踩的坑1.外链链接报错的问题 由于我们当时没没定是内嵌还是外链二维码，所以当时第一种尝试方案就是外链二维码扫码登录。当时是请求后端接口拿到这个二维码地址。点击这个地址发现Scope 参数错误或没有 Scope 权限结果查看文档发现后端返回的redirect_uri没有进行UrlEncode处理。前后端一定得多看几遍文档!!!!!当时拿到二维码链接的时候，一直想要通过img标签把二维码显示出来，试了不行，用iframe试了行是可行。但是样式不对。然后二维码样式直接覆盖也没有用。之后又试了qrcode插件，二维码样式是对了但是扫码之后结果却不是这样的。哎。一言难尽啊！2.内嵌二维码样式显示根据官方文档引入JS文件 其实这个js也是通过iframe来加载二维码的，之后微信登录的时候引入对象。 var obj = new WxLogin({ id: &apos;login_container&apos;, // 需要显示的容器id appid: &apos;************&apos;, // appid scope: &apos;snsapi_login&apos;, // 网页默认即可 redirect_uri: redirectUrl, // 授权成功后回调的url state: dayjs().unix(),// 用来校验 style: &apos;black&apos;, // 二维码的样式 href: &apos;https://******/qrcode.css&apos; // 外部css文件url，需要https }) 注意这个redirect_uri一定要写对，不然二维码显示不出来，如果发现二维码过大或者你不想要的样式，你可以在href填入一个链接。用其中的样式覆盖。 .loginPanel normalPanel {display: flex;} .impowerBox .qrcode {width: 200px;} .impowerBox .title {display: none;} .impowerBox .info {width: 200px;} .status_icon {display: none} .impowerBox .status {text-align: center;} 最终效果：大功告成，虽然结果出来了，但是过程却是一波三折。 总结本人19年毕业的，从事前端开发也有9个月了，加上实习的话都一年多了。希望自己不要盲目自信，多总结经验，多沉淀自己的技术。多向大佬学习。另外码字不容易，希望大家点个赞。前端路漫漫，与君共勉之。]]></content>
      <tags>
        <tag>微信扫码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常总结]]></title>
    <url>%2Fduzuimoye.github.io%2F2019%2F08%2F05%2Fsummarize%2F</url>
    <content type="text"><![CDATA[1: router-view路由匹配到的组件将显示在这里 2: 三位逗号分开1234567891011121314Vue.filter(&apos;numFix&apos;, num =&gt; &#123; let result = &apos;&apos;, nums = [] num = (num || 0).toString() nums = num.split(&apos;.&apos;) while (nums[0].length &gt; 3) &#123; result = &apos;,&apos; + nums[0].slice(-3) + result nums[0] = nums[0].slice(0, nums[0].length - 3) &#125; if (nums[0]) &#123; result = nums[0] + result + (nums[1] ? &apos;.&apos; + nums[1] : &apos;&apos;) &#125; return result&#125;) 或者123456formatNumber(num)&#123; num = num.toFixed(2); num = parseFloat(num) num = num.toLocaleString(); return num;&#125; 3: isNotZero函数1234567Vue.prototype.isNotZero = value =&gt; &#123; if ([null, undefined, &apos;&apos;].includes(value)) &#123; return false &#125; else &#123; return true &#125;&#125; 4: |位运算符6.66| hundred | priceFixed1234567function(value) &#123; return parseFloat(value) * 100&#125; function(value) &#123; return (value / 100).toFixed(2)&#125; 5：http 协议状态码200：请求成功201：请求成功并且服务器创建了新的资源302：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。304：自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。400：服务器不理解请求的语法。401：未经授权 访问被拒绝。404：请求的资源（网页等）不存在500：内部服务器错误503： 服务器错误 6：ios input输入时白屏在input的父元素添加相对定位就行了 style=”position:relative” 7：input获取焦点时 页面被放大设置meta标签12&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt; 8：防抖节流123456789const debounce = (fn, delay) =&gt; &#123; let timer = null; return (...args) =&gt; &#123; clearTimeout(timer); timer = setTimeout(() =&gt; &#123; fn.apply(this, args); &#125;, delay); &#125;;&#125;; 123456789101112// 节流函数const throttle = (fn, delay = 500) =&gt; &#123; let flag = true; return (...args) =&gt; &#123; if (!flag) return; flag = false; setTimeout(() =&gt; &#123; fn.apply(this, args); flag = true; &#125;, delay); &#125;;&#125;; 9instanceof 原理12345678910111213模拟 instanceoffunction instance_of(L, R) &#123; //L 表示左表达式，R 表示右表达式 var O = R.prototype; // 取 R 的显示原型 L = L.__proto__; // 取 L 的隐式原型 while (true) &#123; if (L === null) return false; if (O === L) // 这里重点：当 O 严格等于 L 时，返回 true return true; L = L.__proto__; &#125;&#125; 10mapGettermapGetter函数是将store中的getter映射到局部计算属性 11 computed和methods我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。 12 vue-cloakvue-cloak 可以防止页面闪烁active-class是vue-router模块的router-link组件中的属性，用来做选中样式的切换 13elementUI render-header显示问题12345678910111213141516171819202122232425262728293031323334353637renderSequence(h, &#123; column &#125;) &#123; return h(&apos;span&apos;, [ h(&apos;span&apos;, &#123; domProps: &#123; innerHTML: column.label &#125; &#125;), h( &apos;el-tooltip&apos;, &#123; props: &#123; effect: &apos;dark&apos;, placement: &apos;bottom-start&apos; &#125;, style: &#123; position: &apos;relative&apos;, left: &apos;5px&apos;, opacity: 0.6 &#125; &#125;, [ h(&apos;i&apos;, &#123; class: &apos;el-icon-question&apos;, style: &#123; cursor: &apos;pointer&apos; &#125; &#125;), h(&apos;span&apos;, &#123; domProps: &#123; innerHTML: &apos;数字越小，售卖展示越靠前&apos; &#125;, slot: &apos;content&apos; &#125;) ] ) ])&#125; 14 关于upload action的问题一般会做一下处理1234567891011&lt;el-form-item required label=&quot;上传图片：&quot;&gt; &lt;div v-if=&quot;form.cardFaceImg&quot; class=&quot;card-img&quot;&gt; &lt;img :src=&quot;form.cardFaceImg&quot; alt /&gt; &lt;/div&gt; &lt;div style=&quot;display: inline-block;&quot;&gt; &lt;el-upload action=&quot;//up.qbox.me/&quot; :show-file-list=&quot;true&quot; :file-list=&quot;form.fileList&quot; :on-success=&quot;AvatarSuccess&quot; :before-upload=&quot;AvatarUpload&quot; :data=&quot;imgData&quot;&gt; &lt;el-button :plain=&quot;true&quot; type=&quot;info&quot;&gt;上传图片&lt;/el-button&gt; &lt;/el-upload&gt; &lt;p style=&quot;color: #9b9b9b;margin-top: 5px;&quot;&gt;建议尺寸240*105，不超过500kb&lt;/p&gt; &lt;/div&gt; &lt;/el-form-item&gt; 123456789101112131415161718192021222324AvatarSuccess(res, file) &#123; this.$set(this.form, &apos;cardFaceImg&apos;, &apos;https://asset.imuge.net/&apos; + res.key) this.form.fileList.push(&#123; name: &apos;https://asset.imuge.net/&apos; + res.key &#125;) &#125;, AvatarUpload(file) &#123; let _this = this const isLt2M = file.size / 1024 / 1024 &lt; 0.5 if (!isLt2M) &#123; this.$message.error(&apos;上传礼品图片大小不能超过 500KB!&apos;) return false &#125; return _this.$http.post(apiRoutes.GET_UPLOAD_TOKEN).then( res =&gt; &#123; _this.imgData = &#123; token: res.data.uptoken &#125; &#125;, res =&gt; &#123;&#125; ) &#125; 15 js 字符串两边截取空白的 trim 的原型方法的实现123456// 删除左右两端的空格function trim(str)&#123; return str.replace(/(^\s*)|(\s*$)/g, &quot;&quot;);&#125;// 删除左边的空格 /(^\s*)/g// 删除右边的空格 /(\s*$)/g 16 vue总结首先，我们知道vue实现的单页应用中一般不会去刷新页面，因为刷新之后页面中的vuex数据就不见了。其次，我们也知道一般情况下，url变更的时候，比如指定location.href、history.push、replace等，页面就会刷新。那么问题来了，vue页面的页面跳转时怎么实现的？没刷新页面么？没刷新页面，又要改变url，加载新内容怎么做的？vue-router就是利用pushState这个属性，在页面前进的时候动态改变history的内容，添加一条记录，接着location跟着改变。同时根据router前往的路由获取对应的js资源文件并挂载到目标dom上实现页面内容的更新，但是页面本身并没有刷新。 可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点： 能更快获取到服务端数据，减少页面 loading 时间；ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性； 17 vue路由的钩子函数首页可以控制导航跳转，beforeEach，afterEach等，一般用于页面title的修改。一些需要登录才能调整页面的重定向功能。 beforeEach主要有3个参数to，from，next： to：route即将进入的目标路由对象， from：route当前导航正要离开的路由 next：function一定要调用该方法resolve这个钩子。执行效果依赖next方法的调用参数。可以控制网页的跳转。 18手机号验证1234567function checkPhone()&#123; var phone = document.getElementById(&apos;phone&apos;).value; if(!(/^1(3|4|5|7|8)\d&#123;9&#125;$/.test(phone)))&#123; alert(&quot;手机号码有误，请重填&quot;); return false; &#125; &#125; ^1(3|4|5|7|8)d{9}$，表示以 1 开头，第二位可能是 3/4/5/7/8 等的任意一个，在加上后面的 d 表示数字 [0-9] 的 9 位，总共加起来 11 位结束。 手机号码格式验证方法(正则表达式验证)支持最新电信 199， 移动 198， 联通 166 let valid_rule = /^(13[0-9]|14[5-9]|15[012356789]|166|17[0-8]|18[0-9]|19[8-9])[0-9]{8}$/; if ( ! valid_rule.test(phone_number)) { alert(‘手机号码格式有误’); return false;} 19 new操作符做了什么1、创建一个空对象，并且 this 变量引用该对象，// lat target = {};2、继承了函数的原型。// target.proto = func.prototype;3、属性和方法被加入到 this 引用的对象中。并执行了该函数func// func.call(target);4、新创建的对象由 this 所引用，并且最后隐式的返回 this 。// 如果func.call(target)返回的res是个对象或者function 就返回它 123456789function new(func) &#123; lat target = &#123;&#125;; target.__proto__ = func.prototype; let res = func.call(target); if (typeof(res) == &quot;object&quot; || typeof(res) == &quot;function&quot;) &#123; return res; &#125; return target;&#125; 20 dayJS轻量化工具当前时间 dayjs()时间字符串 dayjs(‘2018-06-03’)时间戳 dayjs(1528361259484)Date 对象 dayjs(new Date(2018,8,18))复制 dayjs().clone()检测当前 Dayjs 对象是否是一个有效的时间 dayjs().isValid()获取 年 ： dayjs().year() 月 ： dayjs().month() 日 ： dayjs().date() 星期 ： dayjs().day() 时 ： dayjs().hour() 分 ： dayjs().minute() 秒 ： dayjs().second() 毫秒 ： dayjs().millisecond()设置 dayjs().set(‘year’,2017) dayjs().set(‘month’,9)增加时间并返回一个新的 Dayjs() 对象 dayjs().add(7, ‘day’) dayjs().add(7, ‘year’)减少时间并返回一个新的 Dayjs() 对象 dayjs().subtract(7, ‘year’) dayjs().subtract(7, ‘month’)返回当前时间的开头时间的 Dayjs() 对象，如月份的第一天。 dayjs().startOf(‘year’) dayjs().startOf(‘month’)返回当前时间的末尾时间的 Dayjs() 对象，如月份的最后一天。 dayjs().endOf(‘month’) dayjs().endOf(‘year’)格式化 dayjs().format() dayjs().format(‘YYYY-MM-DD dddd HH:mm:ss.SSS A’)时间差 dayjs(‘2018-06-08’).diff(dayjs(‘2017-06-01’),’years’) dayjs(‘2018-06-08’).diff(dayjs(‘2017-06-01’),’day’) dayjs(‘2018-06-08’).diff(dayjs(‘2017-06-01’),’hour’)Unix 时间戳 (毫秒) dayjs().valueOf()Unix 时间戳 (秒) dayjs().unix()返回月份的天数 dayjs().daysInMonth()返回原生的 Date 对象 dayjs().toDate()返回包含时间数值的数组 dayjs().toArray()当序列化 Dayjs 对象时，会返回 ISO8601 格式的字符串 dayjs().toJSON() //2018-06-08T02:44:30.599Z返回 ISO8601 格式的字符串 dayjs().toISOString() //2018-06-08T02:46:06.554Z返回包含时间数值的对象 dayjs().toObject()字符串 dayjs().toString()检查一个 Dayjs 对象是否在另一个 Dayjs 对象时间之前 dayjs(‘2018-06-01’).isBefore(dayjs(‘2018-06-02’))检查一个 Dayjs 对象是否和另一个 Dayjs 对象时间相同 dayjs().isSame(dayjs())检查一个 Dayjs 对象是否在另一个 Dayjs 对象时间之后 dayjs().isAfter(dayjs()) 21 Array.from() 五个超好用的用途1：Array.from() 第一个用途：将类数组对象转换成数组。function sumArguments() { return Array.from(arguments).reduce((sum, num) =&gt; sum + num);}sumArguments(1, 2, 3); // =&gt; 6 2：Array.from() 可以很容易的实现数组的浅拷贝。const numbers = [3, 6, 9];const numbersCopy = Array.from(numbers);numbers === numbersCopy; // =&gt; false 3：数组去重Array.from() 的入参是可迭代对象，因而我们可以利用其与 Set 结合来实现快速从数组中删除重复项。12345function unique(array) &#123; return Array.from(new Set(array));&#125;unique([1, 1, 2, 3, 3]); // =&gt; [1, 2, 3] 4：使用值填充数组如果你需要使用相同的值来初始化数组，那么 Array.from() 将是不错的选择。1234const length = 3;const init = 0;const result = Array.from(&#123; length &#125;, () =&gt; init);result; // =&gt; [0, 0, 0] 5：生成数字范围使用 Array.from() 生成值范围。例如，下面的 range 函数生成一个数组，从0开始到 end - 1。1234function range(end) &#123; return Array.from(&#123; length: end &#125;, (_, index) =&gt; index);&#125;range(4); // =&gt; [0, 1, 2, 3] 22 this.$router.push1：query 相当于ajax的get传参 在流浪器地址中会带入参数 而params相当于post的传参 不会在浏览器地址中带参数2：query 要通过path来引入路由 而 params则是通过name来 23 vue中ref的作用ref除了可以获取本页面的dom元素，还可以拿到子组件中的data和去调用子组件中的方法this.$router.back()可以返回上一层 24 border-bottom如何指定它的宽度利用伪元素after.type-list-item{ font-size:26px; font-weight:400; width:100px; height:23px; color:rgba(0,0,0,1); text-align: center; position: relative; } .active{ color: #E4262D; &amp;:after { content: ‘’; position: absolute; bottom: -15px; top: auto; left: 40px; height: 3px; width: 22px; background-color: #E4262D; } } 25 Object.keys(),Object.values(),Object.entries()区别Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。1234let obj = &#123; a: 1, b: 2, c: 3 &#125;;for (let key of Object.keys(obj)) &#123; console.log(key); // &apos;a&apos;, &apos;b&apos;, &apos;c&apos;&#125; Object.values() 返回数组，成员是参数对象自身的（不含继承的）所有可遍历(enumerable)属性的键值1234let obj = &#123; a: 1, b: 2, c: 3 &#125;;for (let key of Object.values(obj)) &#123; console.log(key); // 1, 2, 3&#125; entries()函数会将 key 和 value 以数组的形式都返回。这样，使用循环或则将对象转为 Map 就很方便了。1234let obj = &#123; a: 1, b: 2, c: 3 &#125;;for (let [key, value] of Object.entries(obj)) &#123; console.log([key, value]); // [&apos;a&apos;, 1], [&apos;b&apos;, 2], [&apos;c&apos;, 3]&#125; 26return和return false的区别 return返回null，起到中断方法执行的效果，事件处理函数将会继续执行，表单将提交 return false，事件处理函数会取消事件，不再继续向下执行。比如表单将终止提交。 27 v-lazynpm install vue-lazyload 有这个插件 28 怎么解决iconfont图标不能为渐变色用background-clip text可以解决 但是现在只有chrome 支持，所以通常想使用它，需要 -webkit-background-clip:text1234background linear-gradient(90deg, rgba(253, 110, 88, 1) 0%, rgba(255, 63, 78, 1) 100%)background-clip text-webkit-background-clip text-webkit-text-fill-color transparent //text-fill-color打造镂空文字 29 dayjs如何把时间戳转化为标准时间 引入dayjs dayjs是一个轻量的处理时间和日期的JavaScript 库 formateTime(time) { return dayjs.unix(time).format(‘YYYY-MM-DD HH:mm:ss’) } 30 对于价格的优化12&lt;span class=&quot;integer&quot;&gt;&#123;&#123; (item.price + &apos;&apos;).split(&apos;.&apos;)[0] &#125;&#125;&lt;/span&gt; //+ &apos;&apos;是把价格变成字符串&lt;span class=&quot;decimal&quot; v-if=&quot;(item.price + &apos;&apos;).split(&apos;.&apos;).length &gt; 1&quot;&gt;.&#123;&#123; (item.price + &apos;&apos;).split(&apos;.&apos;)[1] &#125;&#125;&lt;/span&gt; 31 对于从后端取过来的数据优化this.orderList = res.result ? res.result.list : [] 【Vuex】mapGetters 辅助函数mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：1：mapState工具函数会将store中的state映射到局部计算属性中 …mapState({ add: state =&gt; state.add, counts: state =&gt; state.counts })2：mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性： …mapGetters([‘userInfo’])3：mapMutations将 store 中的 action 映射到局部计算属性…mapMutations({ ‘ADD’: ‘ADD’ })…展开运算符1.展开函数在多个参数的地方使用 。意指用于函数传参2.多个元素的地方使用，意指用于数组字面量3.多个边框的地方使用，意指用于解构赋值…this.$route.query, 32 手机号隐藏中间四位一般都会用正则表达式123var tel = &quot;13122223333&quot;;var reg = /^(\d&#123;3&#125;)\d&#123;4&#125;(\d&#123;4&#125;)$/;tel = tel.replace(reg, &quot;$1****$2&quot;); 33 v-model 如果是输入框 , 可以直接使用 v-model=””. .trim 表示去除输入内容的收尾空格 .number 表示将输入的字符串转换为数值类型 .lazy 表示让数据的更新在输入改变时进行. 34 tab点击切换时一大一小？记得给不是active的盒子一个border就可以了 35 substring substr slice splice区别1:substring(start,stop)表示返回从start开始到stop处之间的新字符串，其长度为stop减 start。包含start，但不包含stop，且不修改原字符串。2: substr（index，length）index：表示起始位置 length：表示截取内容长度 且不修改原字符串3:slice可操作数组和字符串，但substring和substr只能操作字符串.slice(start,stop)表示截取从下标start 到下标stop（不包括stop）的之间的元素，并返回新数组/新字符串，并不修改原数组/原字符串.4:splice(start,length,items)表示从下标start处截取length长度（与substr有点像）的元素后，在start处为原数组添加items，并返回被截取的新数组，splice会直接修改原数组具体可看 36 js中!和!!的区别及用法js中!的用法是比较灵活的，它除了做逻辑运算常常会用！做类型判断，可以用！与上对象来求得一个布尔值！可将变量转换成boolean类型，null、undefined和空字符串取反都为false，其余都为true。!null = true！！常常用来做类型判断，在第一步!（变量）之后再做逻辑取反运算不好的写法var a;if(a!=null&amp;&amp;typeof(a)!=undefined&amp;&amp;a!=’’){ //a有内容才执行的代码}最佳写法if(!!a){ //a有内容才执行的代码…} 37 padStart padEndpadStart()用于头部补全，padEnd()用于尾部补全。padStart()和padStart()一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。x’.padStart(5, ‘ab’) // ‘ababx’如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。‘xxx’.padStart(2, ‘ab’) // ‘xxx’ 38 vuex数据异步造成初始化的时候没值报错1: 在computed赋值该数据 并且在dom渲染的时候做非空的判断isShow() { return this.customerInfo ? true : false}2: 通过watch和mouted监听并且初始化vuex数据在mounted的时候初始化该数据 并且watch该数据(不推荐)3: 使用拓展运算符具体可看 39 flex 布局会让position absolute bottom 0 失效？？？？40 this.nextTick()this.$nextTick()在页面交互，尤其是从后台获取数据后重新生成dom对象之后的操作有很大的优势，这里只是简单的例子，实际应用中更为好用.使用this.$nextTick()可以等待dom生成以后再来获取dom对象 41 跳转在vue中使用 this.$router.push（{ path: ‘/home’ }） 默认是替代本窗口如果想新开一个窗口，可以使用下面的方式：this.$router.resolvelink to :to={name: cart} 42 使用navigator.userAgent.toLowerCase()判断登陆端是pc还是手机&#123;123456789101112131415161718192021222324252627 let ua = navigator.userAgent.toLowerCase() this.timer = setInterval(() =&gt; &#123; /* global androidToJs,bsg */ /* eslint no-undef: &quot;error&quot; */ try &#123; if (/iphone|ipad|ipod/.test(ua)) &#123; if (bsg) &#123; //获取pushId, 用于极光推送 this.getPushId &amp;&amp; this.getPushId() //获取app品牌（定制登录） this.getAppBrand &amp;&amp; this.getAppBrand() clearInterval(this.timer) &#125; &#125; else if (/android/.test(ua)) &#123; if (androidToJs) &#123; //获取pushId, 用于极光推送 this.getPushId &amp;&amp; this.getPushId() //获取app品牌（定制登录） this.getAppBrand &amp;&amp; this.getAppBrand() clearInterval(this.timer) &#125; &#125; &#125; catch (error) &#123; return error &#125; &#125;, 10)&#125; 43 JSON.stringfy() undefined、任意的函数以及 symbol 作为对象属性值时 JSON.stringify() 将跳过（忽略）对它们进行序列化 undefined、任意的函数以及 symbol 作为数组元素值时，JSON.stringify() 会将它们序列化为 null undefined、任意的函数以及 symbol 被 JSON.stringify() 作为单独的值进行序列化时都会返回 undefined 44 mixins的特点： 1、方法和参数在各组件中不共享 比如混入对象中有一个 cont:1 的变量,在组件A中改变cont值为5，这时候在组件B中获取这个值，拿到的还是1，还是混入对象里的初始值，数据不共享 2、值为对象的选项，如methods,components等，选项会被合并，键冲突的组件会覆盖混入对象的，比如混入对象里有个方法A，组件里也有方法A，这时候在组件里调用的话，执行的是组件里的A方法 3、值为函数的选项，如created,mounted等，就会被合并调用，混合对象里的钩子函数在组件里的钩子函数之前调用，同一个钩子函数里，会先执行混入对象的东西，再执行本组件的 3、与vuex的区别 vuex：用来做状态管理的，里面定义的变量在每个组件中均可以使用和修改，在任一组件中修改此变量的值之后，其他组件中此变量的值也会随之修改。 衍生：vuex中为什么把把异步操作封装在action，把同步操作放在mutations？如果action里面有同步操作会有什么影响？ 在 mutation 中混合异步调用会导致你的程序很难调试。不知道哪个先回调。 Mixins：可以定义共用的变量，在每个组件中使用，引入组件中之后，各个变量是相互独立的，值的修改在组件中不会相互影响。 4、与公共组件的区别 组件：在父组件中引入组件，相当于在父组件中给出一片独立的空间供子组件使用，然后根据props来传值，但本质上两者是相对独立的。 Mixins：则是在引入组件之后与组件中的对象和方法进行合并，相当于扩展了父组件的对象与方法，可以理解为形成了一个新的组件。 45 cursor: pointer鼠标属性 只在pc端生效 在app 设置了无效。 46 link和@import的区别？1.页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载。2.@import是css提供的语法，因此只可以引入css文件。而link是html提供的语法，除了css文件还可以引入其他文件。3.@import会有兼容性问题，只有IE5+才能使用。而link没有兼容性问题。4.可以通过 JS 操作DOM，插入link标签来改变样式；由于 DOM 方法是基于文档的，无法使用@import的方式插入样式。5.link引入的样式权重大于@import引入的样式。 #47 什么时候使用keep-alive元素？当由于数据属性或其他某种响应状态而动态切换组件时，每次将它们切换到渲染状态时，都会被重新渲染。尽管你可能需要这种行为，但在某些情况下重新渲染可能是不合适的。例如在创建时从 API 调用中引入数据的组件。你可能不希望每次动态切换这个组件进行渲染时都调用此 API。这时你可以将组件包含在 keep-alive 元素中。keep-alive 元素缓存该组件并从那里获取它，而不是每次都重新渲染它 48 父元素设置了border-radius，子元素应用了transform，并且父元素设置了overflow:hidden，但是却失效？// 给父元素设置{ position:relative; z-index:1;} 49 content-typeisJson: true json格式的入参123456789101112computed: &#123; apiParams () &#123; let params = &#123; id: &apos;&apos;, name:&apos;&apos;, age: &apos;&apos;, telephone:&apos;&apos; &#125; params.sex = sex &#125;&#125;this.$http.post(api.getUserInfo, this.apiParams, &#123;isJson: true&#125;) 把isjson 去掉 则格式为form-data 50 addEventListener和attachEvent介绍, 原生js和jquery的兼容性写法123456789101112this.$nextTick(() =&gt; &#123; let el = document.getElementById(&apos;userAgreement&apos;) if(el.addEventListener) &#123; el.addEventListener(&apos;click&apos;,() =&gt; &#123; this.goUserAgreement() &#125;) &#125; else if(el.attachEvent) &#123; el.attachEvent(&apos;onclick&apos;,() =&gt; &#123; this.goUserAgreement() &#125;) &#125;&#125;) 51 如何调用安卓的方法1234567891011121314151617export const closeApp = &#123; methods: &#123; getCloseApp() &#123; let ua = navigator.userAgent.toLowerCase() //判断登录端是pc还是手机端 try &#123; if (/iphone|ipad|ipod/.test(ua)) &#123; //closeApp() 就是安卓暴露出来的事件 bsg.closeApp() &#125; else if (/android/.test(ua)) &#123; androidToJs.closeApp() &#125; &#125; catch (error) &#123; return error &#125; &#125; &#125;&#125; 安卓如何调用web的方法。在methods定义mounted: { window.setShowSecret = this.setShowSecret}在methods定义setShowSecret方法就可以了。 52 对于复杂的表单校验verifyItemExtConfigList 为数组对象 校验的是goodsId123456789101112 &lt;el-form-item class=&quot;shopGoods&quot; :prop=&quot;&apos;verifyItemExtConfigList.&apos; + index + &apos;.goodsId&apos;&quot; :rules=&quot;[ &#123; required: true, message: &apos;请选择核销的商品&apos;, trigger: &apos;blur&apos; &#125; ]&quot; &gt;&lt;/el=form-item&gt; 一定不能忘记callback123456789101112let validPercent = (rule, value, callback) =&gt; &#123; if (value === &apos;&apos; || value === undefined || value === null) &#123; callback(new Error(&apos;输⼊不能为空&apos;)) &#125; else &#123; var reg = /^[1-9]\d*$/g if (!reg.test(value)) &#123; callback(new Error(&apos;请输⼊大于0的正整数&apos;)) &#125; else &#123; callback() //这个也不能忘记 否则触发不了保存事件 &#125; &#125; &#125; 53 flex 0 0 40% 圣杯布局123456789.text font-size 12px color #555 &amp;:nth-child(1) flex 0 0 40% //占总宽度的40% &amp;:nth-child(2) flex 0 0 40% //占总宽度的40% &amp;.operate flex 0 0 20% //占总宽度的20% 54 当后台返回的字段名跟前端一些框架绑定的键名不一致时，需要手动转换一下JSON.parse(JSON.stringify(data).replace(/keyName/g, ‘name’))data为数组，keyName为修改前的键名，name为修改后的键名另一种方法12345678let newData = []; let obj = &#123;&#125;; this.data.map(item =&gt; &#123; obj = item; obj[&apos;name&apos;] = item[&apos;keyName&apos;]; delete obj[&apos;keyName&apos;]; newData.push(obj) &#125;) 55 Vue组件data为什么必须是函数因为组件是可以复用的,JS里对象是引用关系,如果组件data是一个对象,那么子组件中的 data属性值会互相污染,产生副作用。所以一个组件的 data 选项必须是一个函数,因此每个实例可以维护一份被返回对象的独立的拷贝。new Vue 的实例是不会被复用的,因此不存在以上问题. 56 div内置img元素，底部总有间距用一个div包裹一个img，会出现img不能完全覆盖div空间，总会在底边留下一点空隙。解决方法1:div设置font-size: 0或line-height: 0，进而行高为0；2:img设置 vertical-align: top 或者 middle/，使其不再以默认基线为对齐方式；3:img设置 display:block，使其变成块级元素。推荐用第三种 57 什么是 CookieHTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息）：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。cookie 存储在客户端： cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。cookie 是不可跨域的： 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的（靠的是 domain） 58 环境的切换我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。axios.defaults.baseURL可以设置axios的默认请求地址就不多说了。123456789// 环境的切换if (process.env.NODE_ENV == &apos;development&apos;) &#123; axios.defaults.baseURL = &apos;https://www.baidu.com&apos;;&#125; else if (process.env.NODE_ENV == &apos;debug&apos;) &#123; axios.defaults.baseURL = &apos;https://www.ceshi.com&apos;;&#125; else if (process.env.NODE_ENV == &apos;production&apos;) &#123; axios.defaults.baseURL = &apos;https://www.production.com&apos;;&#125; 59 有关于部分oppo 华为手机的兼容性问题部分手机（oppo 华为）span 不给inline-block 大小会出现异常. 60 兼容ipad样式有的页面没有给overflow-y: scroll 导致在ipad样式出现问题 61 字符串转数字parseInt()和parseFloat()两个转换函数，将字符串转换成相应的数字。利用js变量弱类型转换 比如+ - * / 62 vue的注意规范之v-if 与 v-for 一起使用当它们处于同一dom节点，v-for的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。 63 vue数据源？怎么操作数据？不要局限于this.$set()赛 数据，还可以在获取接口数据时进行数据操作。 64 如何管理你的路由使用 vue-router，使用import() 生成异步路由，只有在访问时候才会加载模块。为什么使用 import() 会异步加载模块？MDN：在您希望按照一定的条件或者按需加载模块的时候，动态import() 是非常有用的。而静态型的import是初始化加载依赖项的最优选择，使用静态import更容易从代码静态分析工具和 tree shaking 中受益。 65 ref 与通过类名来获取dom节点的区别一般来讲，获取DOM元素，需document.querySelector（”.input1”）获取这个dom节点，然后在获取input1的值。但是用ref绑定之后，我们就不需要在获取dom节点了，直接在上面的input上绑定input1，然后$refs里面调用就行。然后在javascript里面这样调用：this.$refs.input1 这样就可以减少获取dom节点的消耗了this.$refs.leftScroll.scrollTo(0, 0) 66 input标签input 标签可以接受的类型button checkbox file hidden image password radio reset submit text 上传图片 67 合理借用dayjs今天之前的日期置灰12345678910let disabled = falselet nowTime = dayjs().unix()let nowTimeText = dayjs().format(&apos;MM.DD&apos;) + `$&#123;&apos;今天&apos;&#125;`if(item.day &lt; nowTime) &#123; disabled = true&#125;if(item.text == nowTimeText) &#123; disabled = false&#125;return disabled 优雅写法1return dayjs.unix(item.day).isBefore(dayjs(), &apos;date&apos;) 68 position sticky 粘性定位sticky是position:relative和position:fixed的结合体.特性1.sticky不会触发BFC，2.z-index无效，3.当父元素的height：100%时，页面滑动到一定高度之后sticky属性会失效。4.父元素不能有overflow:hidden或者overflow:auto属性。5.父元素高度不能低于sticky高度，必须指定top、bottom、left、right4个值之一。 69获取表头数据1234567for (let dayObj of dayList) &#123; if (statusList.includes(dayObj.name)) &#123; break &#125; else &#123; statusList.push(dayObj.name) &#125;&#125; 70 日期加星期几 合理利用dayjs12345678910111213141516171819202122232425export function filterYTT(time, format = &quot;M.DD&quot;, isFormatWeek = false) &#123; if ( dayjs() .subtract(1, &quot;day&quot;) .format(&quot;YYYY-MM-DD&quot;) === dayjs(time).format(&quot;YYYY-MM-DD&quot;) ) &#123; return &quot;昨天&quot;; &#125; if (dayjs().format(&quot;YYYY-MM-DD&quot;) === dayjs(time).format(&quot;YYYY-MM-DD&quot;)) &#123; return &quot;今天&quot;; &#125; if ( dayjs() .add(1, &quot;day&quot;) .format(&quot;YYYY-MM-DD&quot;) === dayjs(time).format(&quot;YYYY-MM-DD&quot;) ) &#123; return &quot;明天&quot;; &#125; if (isFormatWeek) &#123; let weeks = [&quot;日&quot;, &quot;一&quot;, &quot;二&quot;, &quot;三&quot;, &quot;四&quot;, &quot;五&quot;, &quot;六&quot;]; return &quot;周&quot; + weeks[dayjs(time).day()]; &#125; return dayjs(time).format(format);&#125; 71下载报表在开发后台管理系统的时候，很多地方都要用到导出excel 表格，比如将table中的数据导出到本地，那么实现这种需求往往有两种方案：一、后端开发一个下载链接，前端将这个链接放到 a 标签的 href 中，一点就能下载。 优点：对于前端来说实现简单，不用写过多的代码，也不依赖第三方库，兼容性好 缺点：如果前端操作数据更改了，需要发给后端才能导出123456789101112downLoadFile(FileName) &#123; if (!FileName) &#123; return false &#125; var link = document.createElement(&apos;a&apos;) link.href = window.location.origin + &apos;/beauty/export/download/门店业绩/&apos; + FileName link.style = &apos;visibility:hidden&apos; link.download = FileName + &apos;.xls&apos; document.body.appendChild(link) link.click() document.body.removeChild(link)&#125; 二、前端借助一些第三方库实现。 72 el-scrollbarelement-ui官网的文档时，发现其左侧导航和右边的内容超出屏幕时，滚动条的样式比较小巧，通过浏览器审查工具查看，发现它是使用了el-scrollbar的样式，跟element-ui的组件样式命名一致。但文档中并没有关于这个 scrollbar组件的使用文档，搜索一番得知这是一个隐藏组件，官方在 github 的 issues 中表示不会写在文档中，需要用的自己看源码进行调用。有时很出现横向滚动条得处理一下 &amp;/deep/ &gt;.el-scrollbar__wrap overflow-x hidden overflow-y scroll 73 富文本编辑器 vue2editor12345678&lt;vue-editor class=&quot;editor&quot; :class=&quot;&#123; disabled : form.isDetail &#125;&quot; :disabled=&quot;form.isDetail&quot; useCustomImageHandler @imageAdded=&quot;addImage&quot; v-model=&quot;form.detail&quot;&gt;&lt;/vue-editor&gt; 74 loacalStorage使用在HTML5中，新加入了一个localStorage特性，这个特性主要是用来作为本地存储来使用的，解决了cookie存储空间不足的问题(cookie中每条cookie的存储空间为4k)，localStorage中一般浏览器支持的是5M大小，这个在不同的浏览器中localStorage会有所不同。 storage.setItem(“c”,3) localStorage的优势1、localStorage拓展了cookie的4K限制2、localStorage会可以将第一次请求的数据直接存储到本地，这个相当于一个5M大小的针对于前端页面的数据库，相比于cookie可以节约带宽，但是这个却是只有在高版本的浏览器中才支持的localStorage的局限1、浏览器的大小不统一，并且在IE8以上的IE版本才支持localStorage这个属性2、目前所有的浏览器中都会把localStorage的值类型限定为string类型，这个在对我们日常比较常见的JSON对象类型需要一些转换3、localStorage在浏览器的隐私模式下面是不可读取的4、localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡5、localStorage不能被爬虫抓取到localStorage与sessionStorage的唯一一点区别就是localStorage属于永久性存储，而sessionStorage属于当会话结束的时候，sessionStorage中的键值对会被清空123456789/** *localStorage 存贮 * @param &#123; String &#125; key 属性 * @param &#123; string &#125; value 值 */export const localStorageSet = (key, value) =&gt; &#123; if (typeof (value) === &apos;object&apos;) value = JSON.stringify(value); localStorage.setItem(key, value)&#125;; 1234567/** *localStorage 获取 * @param &#123;String&#125; key 属性 */export const localStorageGet = (key) =&gt; &#123; return localStorage.getItem(key)&#125;; 1234567/** * localStorage 移除ss * @param &#123;String&#125; key 属性 */export const localStorageRemove = (key) =&gt; &#123; localStorage.removeItem(key)&#125;; 75 nuxtNuxt.js 是一个基于 Vue.js 的通用应用框架。通过对客户端/服务端基础架构的抽象组织，Nuxt.js 主要关注的是应用的 UI渲染。 76 微信网页扫码登陆77 将base64转换为文件12345678dataURLtoFile(dataurl, filename) &#123; var arr = dataurl.split(&apos;,&apos;), mime = arr[0].match(/:(.*?);/)[1], bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n); while(n--)&#123; u8arr[n] = bstr.charCodeAt(n); &#125; return new File([u8arr], filename, &#123;type:mime&#125;);&#125; 78 classES6的class可以看作只是一个语法糖。12345678class Polygon &#123; constructor(height, width) &#123; this.area = height * width; &#125;&#125;console.log(new Polygon(4,3).area);// expected output: 12class 是严格模式(strict) 使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。 如果设置border-radius失效，可以在盒子里设置overflow：hidden 79 dialog组件扩展1234&lt;div class=&quot;title&quot; slot=&quot;title&quot;&gt; &lt;span class=&quot;text&quot;&gt;按日排班&lt;/span&gt; &lt;span class=&quot;info&quot;&gt;选择空白格子进行排班&lt;/span&gt;&lt;/div&gt; 80 获取url的参数123456789101112131415161718/** * @param &#123;*&#125; name * @param &#123;*&#125; origin */export function getUrlParams(name, origin = null) &#123; let url = location.href; let temp1 = url.split(&apos;?&apos;); let pram = temp1[1]; let keyValue = pram.split(&apos;&amp;&apos;); let obj = &#123;&#125;; for (let i = 0; i &lt; keyValue.length; i++) &#123; let item = keyValue[i].split(&apos;=&apos;); let key = item[0]; let value = item[1]; obj[key] = value; &#125; return obj[name];&#125; 81 location 包含当前URL的信息window.location.reload()重新刷新页面 82 vue-cookiesthis.$cookie.set(key，value,expireTime) 83 vue监听组件生命周期通常我们监听组件生命周期会使用this.$emit(‘’)来通知父组件。其实还有一种简洁的方法 使用@hook即可监听组件生命周期.1234567891011子组件export default() &#123; mounted( ) &#123; this.$emit(&apos;listenMounted&apos;) &#125;&#125;父组件&lt;list @listenMounted=&quot;listenMounted&quot;&gt;&lt;/list&gt;优雅写法&lt;list @hook:mounted=&quot;listenMounted&quot;&gt;&lt;/list&gt;翻了一遍源码 组件调用了$on监听的事件名符合以hook开头，当前实例的vm._hasHookEvent会为true,如果hasHookEvent为true，组件会在对应生命周期的时候 通过$emit触发对应的vm.$emit(&apos;hook&apos; + hook) 84 js eventLoop机制js异步执行机制：1：所有的任务都有一个主线程，形成一个执行栈。2：主线程之外，还有一个任务队列，只要异步任务有了结果，就在任务队列放置一个事件3：执行栈的同步任务完成之后，就会读取任务队列执行异步任务。4：主线程不断重复三步。 85 elementUI popver组件 v-if 放里面和外面的区别？？123&lt;el-popover placement=&quot;top-start&quot; width=&quot;200&quot; trigger=&quot;hover&quot; :content=&quot;scope.row.remark&quot; v-if=&quot;scope.row.remark !==null&quot;&gt; &lt;i slot=&quot;reference&quot; class=&quot;iconfont icon-xingzhuang2&quot; style=&quot;font-size: 13px; color:rgba(221,221,221,1);margin-left: 5px;cursor:pointer&quot;&gt;&lt;/i&gt;&lt;/el-popover&gt; 如果把v-if放i标签里面 则会导致填完信息之后刷新列表时 弹出框不弹出。 86 样式总结:class=”{ disabled: checkDayIsCurrentMonth(item.day), active: index === activeDayIndex }”可用，分开来对应不同的样式。:style=”{color: getTimeBoxStyle(time).iconColor}设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。如果发现div的宽度高度没上去，给div设置：display:inline-block。原因：块级对象元素会单独占一行显示，多个block元素会各自新起一行，并且可以设置width,height属性。而内联对象元素前后不会产生换行，一系列inline元素都在一行内显示，直到该行排满，对inline元素设置width,height属性无效。 87 cancelToken 用来取消ajax请求的在真实项目中，当路由已经跳转，而上一页的请求还在pending状态，如果数据量小还好，数据量大时，跳到新页面，旧的请求依旧没有停止，这将会十分损耗性能，这时我们应该先取消掉之前还没有获得相应的请求，再跳转页面。这里axios给我们提供了一个方法：cancelToken.12345678910111213141516171819202122232425262728this.$http .post(apiRoutes.BEAUTY_GOODS_COMMON_LIST, params, &#123; cancelToken: new CancelToken(function executor(c) &#123; self.cancel = c // 这个参数 c 就是CancelToken构造函数里面自带的取消请求的函数，这里把该函数当参数用 &#125;) &#125;) .then(res =&gt; &#123; if (res.data.status === 1) &#123; let result = res.data.result this.goodsList = [...this.goodsList, ...result.data] if (this.goodsList.length &lt; result.total) this.busy = false &#125; else &#123; this.busy = true &#125; &#125; else &#123; this.$message.error(res.data.message) &#125; this.loading = false &#125;) .catch(err =&gt; &#123; if (err.constructor &amp;&amp; err.constructor.name === &apos;Cancel&apos;) &#123; return &#125; this.loading = false console.log(err) &#125;) 88 小程序公众号开发公众号小程序开发 使用的是kbone框架1：为了兼容小程序的开发 style里面不要用scoped 命名的时候注意一下2：img标签图片要显示圆形的话 除了设置border-radius: 50% 还要用mode=”aspectFill” 89 今日总结alert([‘10’,’20’]) ‘10’,’20’ alert输出的内容都会默认转化为字符串7.7777toFixed(2) // ‘7.77’ toFixed 最后得到的结果是一个字符串console.log(NaN==NaN) NaN和任何值都不相等 包括它本身 NaN == NaN //false12setDayOperateList(list = []) &#123;&#125;list = []表示如果opts没传就设为[]，防止报错，ES6语法 为什么computed的数据不能双向绑定？？computed里的return,实际上是一个get方法，就是每次vm.someComputed或者页面相应变化的时候，实际上访问的是它的get方法如果只有return的话，是无法实现双向数据绑定的，因为并没有set数据啊，这样永远获得的都是return里面的值，如果响应依赖的话就get依赖进行运算的值，如果是个常量就会一直返回常量我们可以增加一个可以做中转的依赖属性，重写计算属性的set和get方法，这样就能实现计算属性的双向绑定。 90 vue 实现图片拖动换顺序12345678&lt;draggable :list=&quot;form.M06.itemList&quot; style=&quot;display: flex;&quot;&gt; &lt;div v-for=&quot;(item, index) in form.M06.itemList&quot; :key=&quot;index&quot; class=&quot;m03-col&quot;&gt; &lt;div class=&quot;img-box&quot;&gt; &lt;img :src=&quot;item.goodsIcon || item.goodsCover&quot; alt /&gt; &lt;/div&gt; &lt;i class=&quot;iconfont avatar-remove&quot; @click=&quot;removeItem(&apos;M06&apos;, index)&quot;&gt;&amp;#xe6b7;&lt;/i&gt; &lt;/div&gt;&lt;/draggable&gt; 91 axios封装axios 中，提供是否允许跨域的属性——withCredentials，以及配置超时时间的属性——timeout，通过这两个属性，可以轻松处理跨域和超时的问题。axios.defaults.timeout = 10000axios.defaults.withCredentials = true 92 word-wrap1、word-wrap对行内元素是没有效果的 2、一般情况下，元素拥有默认的white-space:normal（自动换行，不换行是white-space:nowrap），可能是元素中设置的white-space是norwrap导致，无法换行。所以需要white-space normalword-break break-all3、table里面的td设置word-wrap也是没有效果 93 el-table-infinite-scroll插件是结合了element的infinite-scroll做的滚动加载 踩的坑1 为什么滚动加载事件没有出来？ 先看看div的高度 有可能是高度影响的 94 公众号二维码太密集 放大才能扫码识别？把二维码携带的信息通过scene转化。 95 watch 和computed的区别computed：1：支持缓存，只有依赖数据发生改变，才会重新进行计算。2：不支持异步，当computed有异步操作时，无法监听数据变化。watch:1: 不支持缓存，当数据发生改变，就会重新计算。2：支持异步。3：接受二个参数，第一个是最新的值，第二个是之前的值。 96 复制到粘贴板123document.execCommand(&apos;copy&apos;)copyinput.select() 点击这个例子的按钮以选中所有在&lt;input&gt;元素中的文字document.execCommand(&apos;Copy&apos;) 复制到粘贴板 97 非指定结合？？98 DOM0 DOM1 DOM2 DOM3 DOM0 :未形成标准的实验性质的初级阶段的DOM DOM1: DOM1级主要定义了HTML和XML文档的底层结构。 DOM2:DOM2级在原来DOM的基础上又扩充了鼠标、用户界面事件、范围、遍历等细分模块，而且通过对象接口增加了对CSS的支持。 DOM3:DOM3进一步扩展了DOM 99 今日总结 offsetParent: 返回一个指向最近的（指包含层级上的最近）包含该元素的定位元素或者最近的 table,td,th,body元素。当元素的 style.display 设置为 “none” 时，offsetParent 返回 null。 offsetTop： 返回的是当前元素相对于offsetParent元素的顶部内边距距离。 document.title.Document 对象是 Window 对象的一部分，可通过 window.document 属性对其进行访问 .popper-class[x-placement^=’bottom’]有个elementUI一定要这样覆盖样式才有用 watch() {ss value(newVal, oldVal) { this.getConfig() } } 相当于 this.$watch(‘panpel.shopId’, (newVal, oldVal) =&gt; { this.getConfig() }) 100 今日总结为什么0.1+0.2 !== 0.3? 精确度问题？那么0.2+0.3 === 0.5呢？ 110 v-if、v-show、v-html 的原理是什么，它是如何封装的？v-if会调用addIfCondition方法，生成vnode的时候会忽略对应节点，render的时候就不会渲染； v-show会生成vnode，render的时候也会渲染成真实节点，只是在render过程中会在节点的属性中修改属性display值； v-html会先移除节点下的所有节点，调用html方法，通过addProp添加innerHTML属性，归根结底还是设置innerHTML为v-html的值 111 清除form里面的某一项校验this.$refs[‘form’].clearValidate(‘name’); 112 代码规范:prop=”‘verifyItemExtConfigList.’ + index + ‘.isFirstVerify’”:prop=”verifyItemExtConfigList.${index}.isFirstVerify“感觉后面那个更加规范一点 113 sort[‘安徽’,’河南’,’北京’].sort((a,b)=&gt;a.localeCompare(b,’zh-CN’))，汉字，如果直接减法的话，得到的是NaN，对数组不进行任何排序 114 日期（周几）import ‘dayjs/locale/zh-cn’ dayjs(time) .locale(‘zh-cn’) .format(‘周dd’) 115 vue3.0学习1:setup 函数的用法，可以代替vue2.0中的data和methods属性，直接把逻辑写在set里就可以。2:ref函数的使用，在template中使用的变量必须要用ref包装一下。3：return 出去的方法 才能在template中使用，这样可以控制暴漏的变量和方法。 116 history和hash区别1：H5的history依靠pushState保存历史记录、监听浏览器在历史记录上前进后退。history模式不是依靠url改变来切换路由的，因为url改变不会触发任何事件（除了hash），所以需要依赖内部实现的subscription，在点击a标签时，阻止默认事件，然后调用subscription.dispatch通知对应的Route组件。React Router中是利用setState做事件派发，子组件从props中获取currentPath然后做匹配判定（判定规则与exact属性有关，以及Switch组件用于「就近匹配」）。控制台输入history.pushState({title: ‘b’}, ‘bbb’, ‘bbbb’)。会立刻发现导航栏的地址改变了，但是当前页面内容不变。如果此时再刷新浏览器的话，会发现404，因为服务器并不能响应该地址。 2：hash修改hash然后回车不会发请求，hash只用于页面定位，也不会发到后台。React Router里有两种模式（还有Memory Mode先不讨论），HashHistory就是利用页面定位实现的不刷新跳转（传统的a标签默认get请求，target为当前tab），本质就是一个浏览器内置的发布订阅（只是能在url上用hash体现出来），改变hash会广播hashchange事件。你在JSX里使用Link组件，它本质是继承了原生a标签（接口继承），在onClick handler中将超链接默认事件阻止，避免了页面重定向。 117 git提交规范feat：新功能（feature） fix：修补bug docs：文档（documentation） style： 格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改bug的代码变动） test：增加测试 chore：构建过程或辅助工具的变动 118 QRCode1234567var React = require(&apos;react&apos;);var QRCode = require(&apos;qrcode.react&apos;);React.render( &lt;QRCode value=&quot;http://facebook.github.io/react/&quot; /&gt;, mountNode); 链接：https://www.npmjs.com/package/qrcode.react 119 css总结对于后台上传的图片可能不统一的图片处理。设置img的宽高，如果使用object-fit属性还会压缩图片。可以在套一层div 使用绝对定位来截取。12345678910111213141516.logo &#123; height: 70px; width: 70px; margin-right: 15px; background-color: #F9FAFB; border-radius: 8px;ss overflow: hidden; position: relative; &#125; .pic &#123; display: block; height: 70px; position: absolute; right: 0; top: 0; &#125; 120 react className库className={classNames(&apos;tabbar-item&apos;, { &apos;tabbar-item-current&apos;: current === item.index, &apos;tabbar-item-1&apos;: item.index === 0, &apos;tabbar-item-2&apos;: item.index === 1, &apos;tabbar-item-3&apos;: item.index === 2, })} 121 css样式总结1234person-list&#123; overflow-x: scroll -webkit-overflow-scrolling:touch &#125; 如果不想要滚动条123person-list::webkit-scrollbar &#123; display: none;&#125; 122 antd 4.x1：table column 有个ellipsis 可设置省略号。不用自己实现1234ellipsis: true,ellipsis: &#123; showTitle: false&#125; 2： antd form表单有 add remove方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&lt;Form.List name=&quot;ruleList&quot;&gt; &#123;(fields, &#123; add, remove &#125;, &#123; errors &#125;) =&gt; ( &lt;div className=&quot;level-box&quot;&gt; &#123;fields.map((&#123; key, name, fieldKey, ...field &#125;) =&gt; ( &lt;div className=&quot;level-list&quot; key=&#123;key&#125;&gt; &lt;div className=&quot;level-list-item&quot;&gt; &lt;Form.Item shouldUpdate noStyle&gt; &#123;(&#123; getFieldValue &#125;) =&gt; &#123; const levelIdList = getFieldValue([&apos;ruleList&apos;, name, &apos;levelIdList&apos;]) || [] return ( &lt;Form.Item &#123;...field&#125; label=&quot;适用层级&quot; name=&#123;[name, &apos;levelIdList&apos;]&#125; fieldKey=&#123;[fieldKey, &apos;levelIdList&apos;]&#125; rules=&#123;[&#123; required: true, message: &apos;请选择层级&apos; &#125;]&#125; labelCol=&#123;&#123; span: 7 &#125;&#125; &gt; &lt;Select placeholder=&quot;请选择&quot; style=&#123;&#123; width: 228 &#125;&#125; mode=&quot;multiple&quot; optionFilterProp=&quot;children&quot; filterOption=&#123;(input, option) =&gt; &#123; const result = option.children .toLowerCase() .indexOf(input.toLowerCase()) &gt;= 0 return result &#125;&#125; &gt; &#123;levelData.map((item) =&gt; ( &lt;Option value=&#123;item.levelId&#125; key=&#123;item.levelId&#125; disabled=&#123; levelIdIsSelected(item.levelId) &amp;&amp; !levelIdList.includes(item.levelId) &#125; &gt; &#123;item.levelName&#125; &lt;/Option&gt; ))&#125; &lt;/Select&gt; &lt;/Form.Item&gt; ) &#125;&#125; &lt;/Form.Item&gt; &lt;Form.Item &#123;...field&#125; label=&quot;获取分值&quot; name=&#123;[name, &apos;addScore&apos;]&#125; fieldKey=&#123;[fieldKey, &apos;addScore&apos;]&#125; rules=&#123;[ &#123; required: true, message: &apos;请输入分值&apos; &#125;, &#123; validateTrigger: &apos;onBlur&apos;, message: &apos;请合并相同的分值项&apos;, validator: validateTitlePass &#125; ]&#125; labelCol=&#123;&#123; span: 7 &#125;&#125; &gt; &lt;InputNumber placeholder=&quot;请输入&quot; style=&#123;&#123; width: 120 &#125;&#125; min=&#123;1&#125; /&gt; &lt;/Form.Item&gt; &lt;/div&gt; &lt;div className=&quot;level-list-item&quot;&gt; &lt;Form.Item &#123;...field&#125; label=&quot;获取限制&quot; name=&#123;[name, &apos;interval&apos;]&#125; fieldKey=&#123;[fieldKey, &apos;interval&apos;]&#125; rules=&#123;[&#123; required: true, message: &apos;请选择限制&apos; &#125;]&#125; labelCol=&#123;&#123; span: 7 &#125;&#125; initialValue=&#123;4&#125; &gt; &lt;Select placeholder=&quot;请选择&quot; style=&#123;&#123; width: 228 &#125;&#125;&gt; &#123;limitList.map((item) =&gt; ( &lt;Option value=&#123;item.id&#125; key=&#123;item.id&#125;&gt; &#123;item.name&#125; &lt;/Option&gt; ))&#125; &lt;/Select&gt; &lt;/Form.Item&gt; &lt;Form.Item &#123;...field&#125; name=&#123;[name, &apos;limitCount&apos;]&#125; fieldKey=&#123;[fieldKey, &apos;limitCount&apos;]&#125; rules=&#123;[&#123; required: true, type: &apos;number&apos;, message: &apos;请输入限制次数&apos; &#125;]&#125; initialValue=&#123;1&#125; &gt; &lt;Form.Item name=&#123;[name, &apos;limitCount&apos;]&#125; noStyle&gt; &lt;InputNumber placeholder=&quot;请输入&quot; style=&#123;&#123; width: 120 &#125;&#125; min=&#123;1&#125; /&gt; &lt;/Form.Item&gt; &lt;span className=&quot;ant-form-text&quot;&gt; 次&lt;/span&gt; &lt;/Form.Item&gt; &lt;/div&gt; &#123;key !== 0 &amp;&amp; ( &lt;div className=&quot;del-item&quot; onClick=&#123;() =&gt; remove(name)&#125;&gt; &lt;img src=&quot;//cdn.myweimai.com/images/3babb557cbb6de45f3b56c7484ceb211_32x32.png&quot; alt=&quot;&quot; /&gt; &lt;/div&gt; )&#125; &lt;/div&gt; ))&#125; &lt;Form.Item &#123;...btnLayout&#125;&gt; &lt;Button icon=&#123;&lt;PlusOutlined /&gt;&#125; onClick=&#123;() =&gt; add()&#125;&gt; 新增适用层级 &lt;/Button&gt; &lt;/Form.Item&gt; &lt;/div&gt; )&#125;&lt;/Form.List&gt; 123 获取url 上的参数123456789export const getUrlParam = (name: string) =&gt; &#123; const reg = new RegExp(&apos;(^|&amp;)&apos; + name + &apos;=([^&amp;]*)(&amp;|$)&apos;); // 构造一个含有目标参数的正则表达式对象 const r = window.location.search.substr(1).match(reg); // 匹配目标参数 if (r != null) &#123; return unescape(r[2]); &#125; else &#123; return null; // 返回参数值 &#125;&#125;;]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试总结]]></title>
    <url>%2Fduzuimoye.github.io%2F2019%2F07%2F26%2Fmianshi%2F</url>
    <content type="text"><![CDATA[1：说一下对call、apply、bind三个区别？自己实现一下bind方法在JS中，call、apply和bind是Function对象自带的三个方法，这三个方法的主要作用是改变函数中的this指向。call、apply、bind方法的共同点和区别： 三者都是用来改变函数的this对象的指向的； 三者第一个参数都是this要指向的对象，也就是想指定的上下文（函数的每次调用都会拥有一个特殊值——本次调用的上下文（context）——这就是this关键字的值。）； 三者都可以利用后续参数传参；bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用apply、call 二者而言，作用完全一样，只是接受参数的方式不太一样.apply最多只能有两个参数,而call可以接受多个参数。实现一个bind方法​12345678910111213141516 Function.prototype.bind2 = function (context) &#123; if (typeof this !== &quot;function&quot;) &#123; throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;); &#125; var self = this; var args = Array.prototype.slice.call(arguments, 1); var fNOP = function () &#123;&#125;; var fBound = function () &#123; var bindArgs = Array.prototype.slice.call(arguments); return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs)); &#125; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound; &#125;​ 2：数组求和12var arr = [1,2,3,4,5];eval(arr.join(&apos;+&apos;)) eval可计算某个字符串的，其中含有要计算的 JavaScript 表达式或要执行的语句。 3：setstate是同步的还是异步的当时毫不犹豫的说了异步的，因为我想的是setstate更新之后不能立马拿到结果。然而并不是。setState在钩子函数中和在合成事件(onClick、onChange)中是异步的，在setTimeout和原生事件（addEventListener）中是同步的 4: 预加载的原理预加载：提前加载图片，当用户需要查看是可以直接从本地缓存中渲染 为什么要使用预加载：在网页加载之前，对一些主要内容进行加载，以提供用户更好的体验，减少等待时间。否则，如果一个页面的内容过于庞大，会出现留白。 解决页面留白的方案：1.预加载 2.使用svg站位图片，将一些结构快速搭建起来，等待请求的数据来了之后，替换当前的占位符 实现预加载的方法： 1.使用html标签 2.使用Image对象 3.使用XMLHTTPRequest对象，但会精细控制预加载过程 5：BFC布局BFC是css布局的一个概念，是一块独立的渲染区域，一个环境，里面的元素不会影响到外部的元素满足下面的条件之一就能触发BFC：（脱离文档流） 【1】根元素，即HTML元素（最大的一个BFC） 【2】float的值不为none 【3】position的值为absolute或fixed 【4】overflow的值不为visible（默认值。内容不会被修剪，会呈现在元素框之外） 【5】display的值为inline-block、table-cell、table-caption那你了解过IFC FFC GFC吗？当时我一脸懵逼？？？我就说这个还真没听过。之后百度了一下GFC（Grid Formatting Contexts）栅格格式化上下文和FFC（Flex Formatting Contexts）Flex格式化上下文，即分别在元素display为grid和flex、 inline-flex 时触发IFC IFC 只有在一个块级元素中仅包含内联级别元素时才会生成。 6: 你了解过tcp ip协议吗？TCP: （Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能，用户数据报协议（UDP）是同一层内 [1] 另一个重要的传输协议。IP: 网络之间互连的协议（IP）是Internet Protocol的外语缩写 网络之间互连的协议也就是为计算机网络相互连接进行通信而设计的协议 如今的IP网络使用32位地址，以点分十进制表示，如192.168.0.1。 地址格式为：IP地址=网络地址+主机地址或 IP地址=网络地址+子网地址+主机地址。 7： 圣杯双飞翼布局左右两栏固定中间自适应的布局，圣杯布局实现左右两栏固宽中间自适应的方案是:在三栏的最外层包裹一个div，然后通过浮动以及定位的方式将所有栏放置到相应的位置从而达到中间自适应左右两边固定的布局。1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;style&gt; .box&#123; border:1px solid red; width: 90%; min-width: 600px; background: gray; padding-bottom: 10px; &#125; .box::after&#123; content:&quot;&quot;; display:block; clear:both; &#125; .center&#123; width: 100%; float:left; &#125; .left&#123; width: 200px; background: yellow; float:left; /*左浮动盒子往左边空出100%的宽度*/ margin-left:-100%; &#125; .right&#123; width: 200px; background: purple; float:left; /*右侧盒子往左边空出盒子本身的宽度*/ margin-left:-200px; &#125; .middle&#123; background: pink; margin-left: 210px; margin-right:210px; &#125; &lt;/style&gt;&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;center&quot;&gt; &lt;div class=&quot;middle&quot;&gt;中间栏&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;left&quot;&gt;左边栏&lt;br&gt;&lt;br&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;右边栏&lt;br&gt;&lt;br&gt;&lt;/div&gt; &lt;/div&gt; 双飞翼布局left、center、right三种都设置左浮动设置center宽度为100%设置负边距，left设置负边距为100%，right设置负边距为自身宽度设置content的margin值为左右两个侧栏留出空间，margin值大小为left和right宽度1234567891011121314151617181920#left, #right, #center &#123; float: left; &#125; #center &#123; width: 100%; background: rgb(206, 201, 201); &#125; #left &#123; width: 200px; margin-left: -100%; background: rgba(95, 179, 235, 0.972); &#125; #right &#123; width: 150px; margin-left: -150px; background: rgb(231, 105, 2); &#125; .content &#123; margin: 0 150px 0 200px; &#125; 8：get请求传参长度的误区、get和post请求在缓存方面的区别 误区：我们经常说get请求参数的大小存在限制，而post请求的参数大小是无限制的。 实际上HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对get请求参数的限制是来源与浏览器或web服务器，浏览器或web服务器限制了url的长度。为了明确这个概念，我们必须再次强调下面几点: HTTP 协议 未规定 GET 和POST的长度限制 GET的最大长度显示是因为 浏览器和 web服务器限制了 URI的长度 不同的浏览器和WEB服务器，限制的最大长度不一样 要支持IE，则最大长度为2083byte，若只支持Chrome，则最大长度 8182byte 补充补充一个get和post在缓存方面的区别： get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。 post不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。 9: ES6特性 Math.trunc方法用于去除一个数的小数部分，返回整数部分 Math.cbrt方法用于计算一个数的立方根 10 什么是CDN和CDN的好处 CDN:CDN是将源站内容分发至最接近用户的节点，使用户可就近取得所需内容，提高用户访问的响应速度和成功率。解决因分布、带宽、服务器性能带来的访问延迟问题，适用于站点加速、点播、直播等场景。好处：1、多域名加载资源一般情况下，浏览器都会对单个域名下的并发请求数（文件加载）进行限制，通常最多有4个，那么第5个加载项将会被阻塞，直到前面的某一个文件加载完毕。因为CDN文件是存放在不同区域（不同IP）的，所以对浏览器来说是可以同时加载页面所需的所有文件（远不止4个），从而提高页面加载速度。2、文件可能已经被加载过并保存有缓存一些通用的js库或者是css样式库，如jQuery，在网络中的使用是非常普遍的。当一个用户在浏览你的某一个网页的时候，很有可能他已经通过你网站使用的CDN访问过了其他的某一个网站，恰巧这个网站同样也使用了jQuery，那么此时用户浏览器已经缓存有该jQuery文件（同IP的同名文件如果有缓存，浏览器会直接使用缓存文件，不会再进行加载），所以就不会再加载一次了，从而间接的提高了网站的访问速度3、高效率你的网站做的再NB也不会NB过百度NB过Google吧？一个好的CDNs会提供更高的效率，更低的网络延时和更小的丢包率。4、分布式的数据中心假如你的站点布置在北京，当一个香港或者更远的用户访问你的站点的时候，他的数据请求势必会很慢很慢。而CDNs则会让用户从离他最近的节点去加载所需的文件，所以加载速度提升就是理所当然的了。5、使用情况分析一般情况下CDNs提供商（如百度云加速）都会提供数据统计功能，可以了解更多关于用户访问自己网站的情况，可以根据统计数据对自己的站点适时适当的做出些许调整。6、有效防止网站被攻击一般情况下CDNs提供商也是会提供网站安全服务的 11: 如何提高首频加载速度1.js外联文件放到body底部，css外联文件放到head内2.http静态资源尽量用多个子域名3.服务器端提供html和http静态资源时最好开启gzip4.在js,css,img等资源响应的http headers里设置expires,last-modified5.尽量减少http requests的数量6.js/css/html/img资源压缩7.使用css spirtes，可以减少img请求次数8.大图使用lazyload懒加载9.避免404，减少外联js10.减少cookie大小可以提高获得响应的时间11.减少dom elements的数量12.使用异步脚本，动态创建脚本 12：promise123456789const promise = new Promise((resolve, reject) =&gt;&#123; console.log(&apos;1&apos;) resolve() console.log(&apos;2&apos;)&#125;)promise.then(() =&gt;&#123; console.log(&apos;3&apos;)&#125;)console.log(&apos;4&apos;) 输出结果：1 2 4 3peomise 构造函数是同步执行的promise.then中的函数是异步执行的 13 vue @click.native 原生点击事件1，给vue组件绑定事件时候，必须加上native ，不然不会生效（监听根元素的原生事件，使用 .native 修饰符）2，等同于在自组件中：子组件内部处理click事件然后向外发送click事件：$emit(“click”.fn) 如果使用router-link标签，加上@click事件，绑定的事件会无效因为：router-link的作用是单纯的路由跳转，会阻止click事件，你可以试试只用click不用native,事件是不会触发的。此时加上.native，才会触发事件 14 js获取event事件（关于流浪器的差异性）1234let e = event || window.event || arguments.callee.caller.arguments[0]window.event // iee.which // Netscape/Firefox/Opera其中argments.callee就是函数体本身，arguments.callee.caller就是函数体的调用函数体 火狐 15vue apiVue.filter(‘numfix’, =&gt;{})注册全局的filter方法 16 为什么要使用函数组件呢？最重要的原因就是函数组件开销低，也就是对性能有好处，在不需要响应式和this的情况下，写成函数式组件算是一种优化方案。 17 关于数组的apipush pop shift unshift some every reverse slice splice map filter reduce join concat sort forEach indexOf includes 改变原数组的api：pop shift push unshift splice sort reverse 18 关于对象的apiobject.keys() object.prototype.toString() object.values() object.entries() Object.is(val1,val2): 是确定两个值是否是相同的值, 19 Vue2.x响应式数据原理Vue在初始化数据时，会使用Object.defineProperty重新定义data中的所有属性，当页面使用对应属性时，首先会进行依赖收集(收集当前组件的watcher)如果属性发生变化会通知相关依赖进行更新操作(发布订阅)。 20 Vue3.x响应式数据原理Vue3.x改用Proxy替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。 proxy只会代理对象的第一层，那么Vue3.0是怎么处理的呢？1：判断当前返回值是不是object,2: 如果是的话就通过reactive方法做代理 衍生2：检测数组的时候，可能会多次触发get/set事件。怎么防止呢？第一：判断key是否为当前对象的自身属性第二：判断新值跟旧值是否相等 21 position有哪些属性？absolute relative fixed sticky(粘性定位，是fixed和relative的结合体) static（默认值 没有定位）inherit(从父元素中间继承) 22 typeOf 原理？js在底层存储变量的时候，为了性能考虑用低位来存储变量类型信息。typeof ‘hello’ // stringtypeof new String(‘hello’) // Object为什么typeof null 时object，是因为 null 全部为0 而typeof判断机器码的前三位。 23 0.1 + 0.2 === 0.3 吗？ 为什么？计算机的底层都是由二进制来表示的，对于 0.1和 0.2 这种数字在用二进制储存的时候会有精度误差 24 img 标签间距问题的原理以及如何解决上下间隙的原因：img是个inline元素=&gt;inline元素会默认产生元素代码中的换行符（也称为空白符=&gt;也可以默认作为一个文本串） 垂直方向上产生间隙的原因：因为img内联元素在浏览器中可能会被当做字符串看待，可能受到front-size字体大小影响，line-height同时会影响空白节点=&gt;添加图片时候下面会多出来一条空白线就是空白节点的作用 25 vue sync作用vue 修饰符sync的功能是：当一个子组件改变了一个 prop 的值时，这个变化也会同步到父组件中所绑定。 26 函数表达式的优先级比函数申明高一些27 for 循环 和forEach循环哪个性能好一点？在千万级别之下 forEach性能高于for。在亿级以上的量级上for循环性能高于forEach区别：1：for循环按顺序遍历 forEach使用迭代器遍历2：for循环是随机访问元素 forEach是顺序链表访问元素（数据结构） 28 数组原型的方法数组原型上面的方法：map forEach filter some reduce sort splice slice includes every push unshift pop shift reverse join find findIndex set其中改变数组的有：map filter sort splice slice concat push pop返回新数组：concat slice 29 问卷总结30 如何转化一个类数组对象？大致原理是怎么样？1Array.from 2Array.prototype.slice.call() 3 定义一个新数组 通过循环push到新数组Array.prototype.slice.call()原理12345678var foo = &#123; 0: &apos;Java&apos;, 1: &apos;Python&apos;, 2: &apos;JavaScript&apos;, length: 3&#125;;// 因为foo对象本身并没有slice方法，所以通过call调用var arr = Array.prototype.slice.call(foo); // [‘Java’,’Python’,’JavaScript’] function ArraySlice(start, end) { CHECK_OBJECT_COERCIBLE(this, “Array.prototype.slice”); var array = TO_OBJECT(this); var len = TO_LENGTH(array.length); var start_i = TO_INTEGER(start); var end_i = len; if (!IS_UNDEFINED(end)) end_i = TO_INTEGER(end); if (start_i &lt; 0) { start_i = len; if (start_i &lt; 0) start_i = 0; } else { if (start_i &gt; len) start_i = len; } if (end_i &lt; 0) { end_i = len; if (end_i &lt; 0) end_i = 0; } else { if (end_i &gt; len) end_i = len; } var result = ArraySpeciesCreate(array, MaxSimple(end_i - start_i, 0)); // 先转换为数组 if (end_i &lt; start_i) return result; // 如果没有任何参数，直接返回数组 if (UseSparseVariant(array, len, IS_ARRAY(array), end_i - start_i)) { %NormalizeElements(array); if (IS_ARRAY(result)) %NormalizeElements(result); SparseSlice(array, start_i, end_i - start_i, len, result); } else { SimpleSlice(array, start_i, end_i - start_i, len, result); } result.length = end_i - start_i; return result;}当没有输入参数的时候，会创建一个新数组，然后把当前数组的所有元素扔进去，最后返回这个新数组 31 数据类型？以及如何存值？基本数据类型：String Null Number Undefined Boolean Symbol(es6新增) BigInt(es10新增 解决了非常大的整数的精确度问题),直接放在栈中，占据空间小，大小固定，因为经常使用，所以放入栈中储存。引用类型：Object (Array, Date, function)同时存在栈和堆中，占据空间大，大小不固定。引用类型在栈中存储了指针，该指针指向堆中该实体的起始地址，当解释器寻找引用值时，先去栈中找地址，获得地址后找找到实体。检查数据类型：typeof instanceof object.prototypem.toString.call()typeof 原理：js在底层存储变量的时候，为了性能考虑用低位来存储变量类型信息。instanceof 原理：用于测试构造函数的prototype属性是否出现在对象原型链的任何位置。123456789instanceof (A,B) = &#123; var L = A.__proto__; var R = B.prototype; if(L === R) &#123; //A的内部属性(prototype属性)__proto__指向B的原型对象 return true; &#125; return false;&#125; 32[‘1’,’2’,’3’].map(parseInt)结果讲解结果：[1,Nan, Nan]将数组的每个元素传递给指定的函数处理，并返回处理后的数组，所以 [‘1’,’2’,’3’].map(parseInt) 就是将字符串1，2，3作为元素；0，1，2作为下标分别调用 parseInt 函数。即分别求出 parseInt(‘1’,0), parseInt(‘2’,1), parseInt(‘3’,2)的结果。parseInt函数：以第二个参数为基数来解析第一个参数字符串，通常用来做十进制的向上取整（省略小数），特点是接受二个参数，parseInt(String, radix)。其中radix解析字符串的基数，基数规则如下： 1） 区间范围介于2~36之间； 2 ） 当参数为 0，parseInt() 会根据十进制来解析； 3 ） 如果忽略该参数，默认的基数规则： 如果 string 以 &quot;0x&quot; 开头，parseInt() 会把 string 的其余部分解析为十六进制的整数；parseInt(&quot;0xf&quot;) //15 如果 string 以 0 开头，其后的字符解析为八进制或十六进制的数字；parseInt(&quot;08&quot;) //8 如果 string 以 1 ~ 9 的数字开头，parseInt() 将把它解析为十进制的整数；parseInt(&quot;88.99f&quot;) //88 只有字符串中的第一个数字会被返回。parseInt(&quot;10.33&quot;) //返回10； 开头和结尾的空格是允许的。parseInt(&quot; 69 10 &quot;) //返回69 如果字符串的第一个字符不能被转换为数字，返回 NaN。parseInt(&quot;f&quot;) //返回NaN 而parseInt(&quot;f&quot;，16) //返回15 [‘1’,’2’,’3’].map(parseInt)即 parseInt(‘1’,0);radix 为 0，parseInt() 会根据十进制来解析，所以结果为 1； parseInt(‘2’,1);radix 为 1，超出区间范围，所以结果为 NaN； parseInt(‘3’,2);radix 为 2，用2进制来解析，应以 0 和 1 开头，所以结果为 NaN。 33 apply call bind区别123456789101112131415161718 var xw = &#123; name : &quot;小王&quot;, gender : &quot;男&quot;, age : 24, say : function() &#123; alert(this.name + &quot; , &quot; + this.gender + &quot; ,今年&quot; + this.age); &#125; &#125; var xh = &#123; name : &quot;小红&quot;, gender : &quot;女&quot;, age : 18 &#125; xw.say(); xw.say.call(xh) xw.say.apply(xh) xw.say.bind(xh)()call和apply都是对函数的直接调用，而bind方法返回的仍然是一个函数 34 三栏式布局1：flex布局.container display flex .left flex 0 0 200px .right flex 0 0 200px .center flex 12: float+margin .left float left width 200px margin-left -100% .right float left width 200px margin-left 200px .center margin-left 200px margin-right 200px 35 setState是同步的还是异步的？setState在原生事件和异步操作中是同步的，在生命周期函数中和合成事件中是异步的。 36 new的时候做了什么？var obj = new Base()1: 创建了一个新对象2：对象obj的proto属性指向了Base的prototype上3: 利用call/apply 为对象obj执行构造方法。 37 set mapset是一种叫做集合的数据结构map是键值对的数据结构 38 虚拟Dom什么是虚拟dom: 用js来模拟dom的节点什么是diff算法： diff算法是进行虚拟节点的对比，并返回一个patch对象，用来储存二个节点的差异，最后用patc记录的信息去局部更新dom。如图所示diff算法的步骤：1：用js对象表示dom树的结构，用这个树去构建一个真正的dom树。2：当状态变更的时候，重新构造一个新的对象树，新的树和旧的树进行对比，记录二棵树之间的差异。3：把所记录的差异应用到真正的dom树，视图更新。 39 vue父子组件生命周期执行顺序加载预览过程：先后顺序为父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted 子组件更新过程：父beforeUpdate-&gt;子beforeUpdate-&gt;子update-&gt;父update 父组件更新过程： 父beofreUpdate -&gt; 父update 销毁过程：父beforeDestory-&gt;子beforeDestory-&gt;子destory-&gt;父destory 40 Object和map的区别？key：Object的key是一些简单的数据类型（string 整数 symbol），而map的key可以是支持js的所有数据类型。也就是说可以是object。元素顺序： map可以按顺序插入map迭代 get set delete size属性。Object 则需要借助 Object.keys() 来计算 41 求二个数组的交集并集1：filter12345678910var a = [1,6,8,9]var b = [1,9,12,78]// 交集var c = a.filter(v =&gt;&#123; return b.indexOf(v) &gt; -1&#125;)// a与b差集var d = a.filter(v =&gt;&#123; return b.indexOf(v) === -1&#125;) 2: set+filter12345678910111213141516var aa = [1,2,3,4,5]var bb = [2,4,6,8,10]ssvar sa = new Set(aa);var sb = new Set(bb);// 交集let intersect = aa.filter(x =&gt; sb.has(x));// 差集let minus = aa.filter(x =&gt; !sb.has(x));// 补集let complement = [...aa.filter(x =&gt; !sb.has(x)), ...bb.filter(x =&gt; !sa.has(x))];// 并集let unionSet = Array.from(new Set([...a, ...b]));console.log(&quot;a与b的交集：&quot;, intersect);console.log(&quot;a与b的差集：&quot;, minus);console.log(&quot;a与b的补集：&quot;, complement);console.log(&quot;a与b的并集：&quot;, unionSet); 42 es6 -&gt; es5bable let const 怎么转化成var? 大概步骤？es6 class可以看作是一个语法糖。 ES5 的构造函数 Person，对应 ES6 的 Person 类的 constructor 方法12345678910class Person&#123; constructor(name) &#123; this.name = name &#125; sayName() &#123; return &apos;my name is&apos; + this.name &#125;&#125;var moye = new Person(&apos;moye&apos;)moye.sayName() es5 写法123456function Person(name) &#123; this.name = name&#125;Person.prototype.sayName = function () &#123; return &apos;my name is&apos; + this.name&#125; 43 双向绑定 拦截页面更新？ setter?44 this.$set原理this.$set(data, ‘isChoosw’, true)在new Vue（）时就注入到vue的原型。 45 webpack是如何解决二次引入的？46 预加载提前加载图片，当用户需要查看时直接从缓存中读取。方式：1：设置link标签 设置rel=prefetch2:script标签3：利用XMLhttpRequest 47 session和cookie的区别cookie 存储有户信息的一种机制，可以设置有效期，大小一般为4k，存在浏览器中。服务器性能好一点。session 是有cookie进行标记的，存在服务器上。安全性能好一点。storage （localStorage sessionStorage） 48 forEach map的区别1：forEach返回的是undefined 不可以进入链式调用。2: map返回的是一个新数组，不改变原数组。3：不能终止forEach循环，除非抛出异常。 49 vue路由守卫1：全局守卫：beforeEach/afterEachbeforeEach三个参数to: 即将要去的路由对象form: 即将要离开的对象next： function 2: 路由独享钩子:beforeEnter/beforeLeave 3: 组件内的守卫钩子： beforeRouterEnter/beforeRouterLeave/beforeRouterUpdate 50 如何在es5的环境下实现let/const利用Object.defineProperty, 去修改属性描述符。123456789101112131415161718192021222324252627var __const = function __const (data, value) &#123; window.data = value // 把要定义的data挂载到window下，并赋值value Object.defineProperty(window, data, &#123; // 利用Object.defineProperty的能力劫持当前对象，并修改其属性描述符 enumerable: false, configurable: false, get: function () &#123; return value &#125;, set: function (data) &#123; if (data !== value) &#123; // 当要对当前属性进行赋值时，则抛出错误！ throw new TypeError(&apos;Assignment to constant variable.&apos;) &#125; else &#123; return value &#125; &#125; &#125;) &#125; __const(&apos;a&apos;, 10) console.log(a) delete a console.log(a) for (let item in window) &#123; // 因为const定义的属性在global下也是不存在的，所以用到了enumerable: false来模拟这一功能 if (item === &apos;a&apos;) &#123; // 因为不可枚举，所以不执行 console.log(window[item]) &#125; &#125; a = 20 // 报错 51 从输入url到获取页面的完整过程1.查询NDS(域名解析),获取域名对应的IP地址 域名解析过程： 第一：查询浏览器缓存， 第二：检查系统缓存，检查host文件,它保存了以前访问过的域名和ip，有的话直接获取， 如果没有的话 第三：检查路由器缓存，如果没有的话 第四：查询DNS缓存，如果还不行的话 第五：递归查询，从根域名服务器到顶级域名服务器再到极限域名服务器依次搜索哦对应 目标域名的IP。 2.浏览器与服务器建立tcp链接（三次握手） 3.浏览器向服务器发送http请求(请求和传输数据） 4.服务器接受到这个请求后，根据路经参数，经过后端的一些处理生成html代码返回给浏览器 5.浏览器拿到完整的html页面代码开始解析和渲染，如果遇到外部的css或者js，图片一样的步骤 6.浏览器根据拿到的资源对页面进行渲染，把一个完整的页面呈现出来 52 三次握手第一次握手：客户端发送一个请求链接、服务端确认自己可以收到报文段。第二次握手：服务端发送一个链接，确认客户端可以收到报文段。第三次握手：服务端确认客户端收到了自己发送的报文段。 53 线程与进程的区别？进程：是执行的一段程序，一旦程序被载入到内存中并准备执行，它就是一个进程。线程：单个进程中执行每个任务就是一个线程。线程是进程中执行运算的最小单位。区别：一个线程只属于同一个进程。但一个进程可以有多个线程。线程与进程的区别 54 http缓存机制Web缓存分为：浏览器缓存、cdn缓存、服务器缓存、数据库缓存。浏览器http缓存：分为强缓存，协商缓存。区别是：协商缓存会发送请求到服务器、链接：https://www.cnblogs.com/ranyonsue/p/8918908.html 55http请求头详细介绍：:authority:ichoice.myweimai.com 请求的域名:method: GET 请求的方法:path: /usercenter/api/user/memberInfo 请求路径 也就是域名后面的ichoice.myweimai.com:scheme: https 请求的协议accept: application/json, text/plain, / 请求文件类型accept-encoding: gzip, deflate, br 压缩类型 支持gzip deflate br 压缩方式accept-language: zh-CN,zh;q=0.9,en;q=0.8 浏览器语言origin: https://m.myweimai.com Origin 仅仅包含站点信息，不包含任何路径信息。 eg: https://baidu.com/ 错误referer: https://m.myweimai.com/ 参照页 来路 先前网页的地址sec-fetch-dest: empty 意为如何使用返回的参数sec-fetch-mode: cors 意为如何使用返回的参数sec-fetch-site: same-siteuser-agent: Mozilla/5.0 (iPhone; CPU iPhone OS 13_2_3 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.3 Mobile/15E148 Safari/604.1 UA信息 表明浏览器的身份 内核 系统http响应头详细介绍cache-control: private, max-age=0 # 缓存控制：私有（缓存0秒，也就是不缓存） max-age=3600 是以秒为单位制定时间时的相应Cache-Control:private默认为private 响应只能够作为私有的缓存，不能再用户间共享Cache-Control:public 响应会被缓存，并且在多用户间共享。正常情况, 如果要求HTTP认证,响应会自动设置为 private.Cache-Control:must-revalidate 响应在特定条件下会被重用，以满足接下来的请求，但是它必须到服务器端去验证它是不是仍然是最新的。Cache-Control:no-cache 响应不会被缓存,而是实时向服务器端请求资源。Cache-Control:max-age=10 设置缓存最大的有效时间，但是这个参数定义的是时间大小（比如：60）而不是确定的时间点。单位是[秒 seconds]。Cache-Control:no-store 在任何条件下，响应都不会被缓存，并且不会被写入到客户端的磁盘里，这也是基于安全考虑的某些敏感的响应才会使用这个。access-control-allow-origin: https://m.myweimai.com 指定哪些网站可以跨域资源共享access-control-expose-headers: x-weimai-token 响应头配置]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue活动页]]></title>
    <url>%2Fduzuimoye.github.io%2F2019%2F07%2F20%2Fvue.huodongye%2F</url>
    <content type="text"><![CDATA[前言最近，公司的PM提了一个需求 自动获取七天新上传的并且审核通过的商品做成固定的链接的一个活动页面。当时想了一想就用vue做了，感觉效果还行，在这分享一下我是如何做的 希望对大家有一点点帮助。 效果图效果 1：页面的构建及优化所谓的活动页 首先第一步肯定是把页面切出来，这里就是2*n页面 我这里用的就是grid布局（也可以用flex）我主要讲三个点： 1:关于图片的优化 由于后段传过来的图片大小不一样，我就对图片做了做了一下优化 。整个图片在填充盒子的同时保留其长宽比代码： 12345678 .product-img img &#123; object-fit: contain; width: auto; height: auto; max-width: 100%; max-height: 100%; margin: 0 auto;&#125; 为了不让图片觉得突兀 我们可以给图片的盒子设置一个伪元素 12345678910111213.product-img::after &#123; content: &apos;&apos;; position: absolute; top: 0; left: 0; -webkit-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0); z-index: 1000; width: 100%; height: 100%; border-radius: .1rem; background: rgba(85, 85, 85, 0.05);&#125; 2:关于页面数据还没加载出来的优化由于从后台获取数据需要一定的时间 当数据没加载进来的时候会出现问题（也许就是一秒但这也会给用户带来不好的体验感。） 1&lt;div class=&quot;container&quot; :class=&quot;productList.length ? &apos;show&apos;: &apos;&apos;&quot;&gt; 当数据没加载的时候我就设置opacity为0，当数据出来的时候就设置opacity：1 3:关于价格的优化由于设计稿的需求是价格的整数的字体要比小数要大，所以就把整数和小数分别用spilt分隔来了。然后在给整数的字体比小数点的字体大一号就行了。 1&lt;div class=&quot;product-price&quot;&gt;￥&lt;span class=&quot;em&quot;&gt;&#123;&#123;String(product.price).split(&apos;.&apos;)[0]&#125;&#125;&lt;/span&gt;.&#123;&#123;String(product.price).split(&apos;.&apos;)[1]||&apos;0&apos;&#125;&#125;/天&lt;/div&gt; 2：获取数据从后台获取数据是很重要的一部分 由于后段给了二个参数 一个是当前页 一个是一个页面有多少条数据。 12345678910getList(cb)&#123; this.getActivityInfoById(this.curPage,this.pageSize).then((data = &#123;&#125;)=&gt;&#123; this.total = data.total; if(( this.curPage * this.pageSize) &gt;= this.total &amp;&amp; document.readyState == &quot;complete&quot;) &#123; this.isMaxPage = true; &#125; this.productList = this.productList.concat(data.rows || []); cb &amp;&amp; cb(data) &#125;)&#125; 123456789101112getActivityInfoById: function(start, length) &#123; return axios .get(this.api.getActivityInfoById, &#123; params: &#123; start: start, length: length &#125; &#125;) .then(function(res) &#123; return res.data.data; &#125;);&#125;, 3:分页所谓的活动页肯定要做分页处理 123456789101112131415161718onPage()&#123; const scrollTop = document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop; const bodyHeight = document.body.offsetHeight; const clientHeight = window.innerHeight; if(scrollTop + clientHeight &lt; bodyHeight)&#123; return; &#125; if(this.isGetList) return; if(this.total &lt; this.curPage * this.pageSize)&#123; return; &#125; this.curPage++; this.isGetList = true; this.getList(()=&gt;&#123; this.isGetList = false; &#125;); &#125;, 4:下拉刷新的优化当数据还在加载中显示loading，当数据加载完成是显示扯到底了12&lt;div class=&quot;footer&quot; v-if=&quot;isMaxPage&quot;&gt;- 不要扯了 已经扯到底了 -&lt;/div&gt;&lt;div class=&quot;footer&quot; v-if=&quot;!isMaxPage&quot;&gt;- loading -&lt;/div&gt; 5：懒加载由于这个活动页图片有点多 所以用了懒加载 1234567891011121314lazyLoad: function() &#123; var seeHeight = document.documentElement.clientHeight; // 可见区域高度 var imgs = document.getElementsByTagName(&apos;img&apos;); for (var i = this.lazyLoadIndex; i &lt; imgs.length; i++) &#123; if ( imgs[i].getBoundingClientRect().top &lt; seeHeight &amp;&amp; imgs[i].dataset.src &amp;&amp; imgs[i].getAttribute(&apos;src&apos;) !== imgs[i].dataset.src ) &#123; imgs[i].setAttribute(&apos;src&apos;, imgs[i].dataset.src); this.lazyLoadIndex++; &#125; &#125;&#125;, 总结作为一个毕业的大四学生，这是我来公司实习做的活动页，希望可以帮助大家，互相学习，一起进步。当然也有一些不足之处，请大家多多指教。码字不容易，希望大家点个赞。前端路漫漫，与君共勉之。]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>H5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue音乐]]></title>
    <url>%2Fduzuimoye.github.io%2F2018%2F07%2F29%2Fvue-music%2F</url>
    <content type="text"><![CDATA[前言最近在自学vue,打算自己仿一个项目来实战一下，由于本人很喜欢听歌，所以就选择了网易云音乐，在这与大家分享一下自己所遇到的问题，其中也有些不足之处也希望大家提一些宝贵的意见，互相学习，一起进步。 关于项目使用的技术栈 Vue：采用Vue的语法 Vuex：实现不同组件之间的状态共享 vue-router：单页应用路由管理必备 axios：发起http请求 SASS(SCSS)：css预处理语言 项目由于时间有限，只是做了个页面的播放功能，其中用到了网易云音乐的API网易云，有兴趣的可以去玩玩，其中也涉及到了一些知识点，在这与大家分享一下。 上图整个效果：) 分享做这个单页面的过程这就是一个header组件，一个footer组件，一个musicList组件和一个paly组件组成的单页面。 1. 如何获取音乐的数据我这是从网易云音乐api扒出来的，扒出来之后新建一个文件，把数据放进去，之后通过axios获取，部分代码如下： 123456789101112131415161718192021actions: &#123; getData(&#123; commit,state &#125;) &#123; if (localStorage.musics !== &apos;[]&apos; &amp;&amp; localStorage.musics) &#123; state.musicData = JSON.parse(localStorage.musics); return; &#125; return new Promise((resolve, reject) =&gt; &#123; Vue.axios.get(&apos;music-data&apos;) .then (res =&gt; &#123; if (res.data.error === 0) &#123; state.musicData = res.data.musicData; localStorage.musics = JSON.stringify(state.musicData); &#125; &#125;) .then(() =&gt; &#123; commit(&apos;toggleMusic&apos;,0) &#125;); resolve(); &#125;); &#125; &#125; 2. 删除功能我是在这删除这个图标下绑定了一个事件，主要就二句代码: 12345&lt;span v-on:click=&quot;del(index)&quot; class=&quot;del-icon&quot;&gt;&lt;/span&gt;在methods定义del事件就好了 del(index)&#123; this.$store.commit(&apos;del&apos;,index); &#125; 3. 尾部的播放控制尾部的播放功能我一开始遇到了一个难题就是如何获取歌曲的时间和控制播放的进度。后来通过查找资料和百度解决了 获取歌曲时间的部分代码如下： 12345678910111213141516171819&lt;span class=&quot;start&quot;&gt;&#123;&#123;transformTime(now)&#125;&#125;&lt;/span&gt;js部分代码 this.nativeAudio = document.querySelector(&apos;audio&apos;); this.nativeAudio.addEventListener(&apos;play&apos;, () =&gt; &#123; this.totalTime = this.transformTime(this.nativeAudio.duration); this.now = this.nativeAudio.currentTime; setInterval(() =&gt; &#123; this.now = this.nativeAudio.currentTime; &#125;, 1000) &#125;) transformTime(seconds) &#123; let m, s; m = Math.floor(seconds / 60); m = m.toString().length == 1 ? (&apos;0&apos; + m) : m; s = Math.floor(seconds - 60 * m); s = s.toString().length == 1 ? (&apos;0&apos; + s) : s; return m + &apos;:&apos; + s; &#125; 控制播放进度的部分代码如下 123456789101112131415161718192021changeTime(event) &#123; let progressBar = this.$refs.progressBar; let coordStart = progressBar.getBoundingClientRect().left; //getBoundingClientRect()方法返回元素的大小及其相对于视口的位置 let coordEnd = event.pageX; this.nativeAudio.currentTime = (coordEnd - coordStart) / progressBar.offsetWidth * this.nativeAudio.duration; this.now = this.nativeAudio.currentTime; this.nativeAudio.play(); this.$store.commit(&apos;play&apos;, true); &#125;,touchMove(event) &#123; let progressBar = this.$refs.progressBar; let coordStart = progressBar.getBoundingClientRect().left; let coordEnd = event.touches[0].pageX; this.$refs.now.style.width = ((coordEnd - coordStart) / progressBar.offsetWidth).toFixed(3) * 100 + &apos;%&apos;; //toFixed(3)保留小数点后3位 &#125;,touchEnd(event) &#123; this.nativeAudio.currentTime = this.$refs.now.style.width.replace(&apos;%&apos;, &apos;&apos;)/100 * this.nativeAudio.duration; this.now = this.nativeAudio.currentTime; this.nativeAudio.play(); this.$store.commit(&apos;play&apos;, true); &#125;, 4. 换肤换肤主要提供了四种颜色，红色 蓝色 黑色 和绿色，样式使用的是flex布局，主要css代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960.skin &#123; position: absolute; display: flex; flex-direction: column; bottom: 50px; right: 15px; width: 30px; .skin-colors &#123; flex: 4; width: 100%; display: flex; justify-content: center; align-items: center; flex-direction: column; .selected &#123; border: 1px solid white; &#125; i &#123; flex: 1; display: inline-block; width: 20px; height: 20px; cursor: pointer; border-radius: 10px; margin-bottom: 5px; &#125; i.one &#123; background-color: #B72712; &#125; i.two &#123; background-color: #1565C0; &#125; i.three &#123; background-color: #212121; &#125; i.four &#123; background-color: #1B5E20; &#125; &#125; .icon-skin &#123; flex: 1; width: 100%; height: 30px; background-repeat: no-repeat; background-size: contain; margin-top: 3px; cursor: pointer; &#125; .icon-skin-red &#123; background-image: url(&apos;./skinRed.svg&apos;); &#125; .icon-skin-green &#123; background-image: url(&apos;./skinGreen.svg&apos;); &#125; .icon-skin-blue &#123; background-image: url(&apos;./skinBlue.svg&apos;); &#125; .icon-skin-black &#123; background-image: url(&apos;./skinBlack.svg&apos;); &#125; 5. 控制歌曲的上一首下一首的播放部分代码如下： 123456789prev() &#123; this.audio.index = this.audio.index === 0 ? this.musicData.length - 1 : (--this.audio.index); this.$store.commit(&apos;toggleMusic&apos;, this.audio.index);&#125;next() &#123; this.audio.index = this.audio.index === this.musicData.length - 1 ? 0 : (++this.audio.index); this.$store.commit(&apos;toggleMusic&apos;, this.audio.index);&#125; 总结：通过模仿这个项目更加清楚地了解各组件之前的使用和不同组件的状态共享。当然也遇到了一些坑，文章写到这里，也没有完全写完，只写了一个单页面，但也算是一个小小的总结，接下来附上我的源码：项目源码，有兴趣的朋友可以看看顺便帮忙点个star和fork,也希望能帮助到一些朋友。作为一名快要成为大四的学生，时间真的宝贵，对待学习也不敢懈怠，如果大家有什么好的想法的话可以联系我的qq:137032979.码字不容易，希望大家点个赞。前端路漫漫，与君共勉之。]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>网易云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序]]></title>
    <url>%2Fduzuimoye.github.io%2F2018%2F06%2F17%2Ffurniture%2F</url>
    <content type="text"><![CDATA[微信小程序–家具篇今年是小程序很火的一年，所以最近在自学微信小程序，所以打算自己撸一个小程序出来，由于自己才刚刚自学不久。就做了一个相对简单的家具小程序。当然在这其中也遇到了一些问题和bug,在这就和大家分享一下，这样才能帮助更多的朋友。如有不足之处，希望大家提出宝贵的建议哈。这样才能一起成长，一起进步。 简单介绍一下微信小程序众所周知，随着越来越多的app出现在了App商城，导致手机下载多了app会导致手机卡，所以这时微信小程序腾空而出。只要用户扫一扫或者搜索一下就能打开应用，减少了我们下载app的次数。 开发环境：WXML(HTML),WXSS(CSS),Javascript 开发工具：vscode，微信开发者工具 开发流程：下载微信开发者工具之后注册一下就会有自己的AppID，微信小程序有官方的微信小程序开发文档 接下来说说我做的小程序吧万事开头难，关键是踏出第一步。在这里我将分享一下我实现过程以及在实际过程中遇到的坑。首先先看看首页效果吧 代码实现，主页东西也不多，主要是布局问题。 wxss代码： .img-box image{ width: 100%; height: 100%; } .img-box image:after{ content: &quot;&quot;; position: absolute; bottom: 0; width: 100%; color: #fff; padding: 50px 20px; } 1：家具的轮播效果实现小程序的轮播实现是用了swiper组件，滑块视图容器里面有indicator-dots,autoplay,setinterval等属性，可以设置自动播放，时间间隔。插入的图片可以用wx:for来循环。 wxml代码： &lt;swiper class=&quot;section &quot;indicator-dots=&quot;{{true}}&quot; autoplay=&quot;autoplay&quot; setInterval=&quot;3000&quot; duration=&quot;500&quot;&gt; &lt;view class=&quot;img-box&quot;&gt; &lt;block wx:for=&quot;{{slides}}&quot; wx:key=&quot;id&quot;&gt; &lt;swiper-item&gt; &lt;image src=&quot;{{item.image}}&quot; mode=&quot;aspectFill&quot; /&gt; &lt;/swiper-item&gt; &lt;/block&gt; &lt;/view&gt; &lt;/swiper&gt; 我这里把图片放在了js里面遍历。效果如图所示 2：navigate的跳转问题在点击加入购物车以后，加入绑定事件本该跳转到另一个页面的，但是迟迟没有出现效果也没有报错，我以为我拼写或路径有问题，但我检查之后没有问题啊，后来终于发现了一个坑。这里要跳转的是tabBar的页面，按照默认的跳转是不允许的，查看了一下开发文档才发现 解决办法：把navigateTo换成switchTab就可以了跳转有很多种方法，具体可以查看开发文档。跳转页面的api 3：商品如何加入购物车之后如何控制购买商品的数量并计算价格本来想做的是点击图片进入详情再点击加入购物车就能保存到后台的购物车里 但是由于自学的知识有限，后端目前还没学，只能加入一个绑定事件跳转到购物车。 接下来计入正题：如何控制购物车购买的数量和计算总价？先在js里面定义一个cart空的数组，我们先把这个值赋给这个空数组，之后再取这个值。之后给商品的状态默认为选择状态，点击一下，就可以把状态变为取消。话不多说，之后计算出选择商品的总价。先看这个效果吧 js代码： selectList(e){ let selectAllStatus = this.data.selectAllStatus; const index=e.currentTarget.dataset.index; let carts=this.data.carts; const selected=carts[index].selected; carts[index].selected=!selected; selectAllStatus = carts[index].selected; // if( carts[index].selected=!selected){ // selectAllStatus:false; // } this.setData({ carts, selectAllStatus, }); this.getTotalPrice(); }, deleteList(e) { const index = e.currentTarget.dataset.index; let carts = this.data.carts; carts.splice(index,1); this.setData({ carts: carts }); if(!carts.length){ this.setData({ hasList: false }); }else{ this.getTotalPrice(); } }, addCount (e){ const index = e.currentTarget.dataset.index; let carts = this.data.carts; let num = carts[index].num; num++; carts[index].num = num this.setData({ carts }) this.getTotalPrice(); }, minuCount(e){ const index = e.currentTarget.dataset.index; let carts = this.data.carts; let num = carts[index].num; if(num&lt;=1) return false; num--; carts[index].num = num this.setData({ carts }); this.getTotalPrice(); }, selectAll(e){ let selectAllStatus = this.data.selectAllStatus; selectAllStatus = !selectAllStatus; let carts =this.data.carts; for(let i=0;i&lt;carts.length;i++){ if( carts[i].selected=!selectAllStatus){ selectAllStatus:false } carts[i].selected=selectAllStatus; } this.setData({ carts, selectAllStatus }) this.getTotalPrice(); }, getTotalPrice(){ let carts = this.data.carts; let total = 0; for(let i =0;i&lt;carts.length;i++){ // total += carts[i].num *carts[i].price; if(carts[i].selected){ total+= carts[i].num * carts[i].price; } } this.setData({ totalPrice:total.toFixed(2) }) } 4：如何获取登录微信的用户的头像和信息1.使用wx.getUserInfo直接获取微信头像，昵称。2.我们在使用小程序wx.login API进行登录的时候，直接使用wx.getUserInfo是不能获取更多的信息的，如微信用户的openid。我这里是用的第一种方法wxml代码： &lt;view class=&quot;userinfo&quot;&gt; &lt;button wx:if=&quot;{{!hasUserInfo && canIUse}}&quot; open-type=&quot;getUserInfo&quot; bindgetuserinfo=&quot;getUserInfo&quot;&gt; 获取头像昵称 &lt;/button&gt; &lt;block wx:else&gt; &lt;image bindtap=&quot;bindViewTap&quot; class=&quot;userinfo-avatar&quot; src=&quot;{{userInfo.avatarUrl}}&quot; background-size=&quot;cover&quot;&gt;&lt;/image&gt; &lt;text class=&quot;userinfo-nickname&quot;&gt;{{userInfo.nickName}}&lt;/text&gt; &lt;/block&gt; &lt;/view&gt; js代码： onLoad: function () { if (app.globalData.userInfo) { this.setData({ userInfo: app.globalData.userInfo, hasUserInfo: true }) } else if (this.data.canIUse){ // 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回 // 所以此处加入 callback 以防止这种情况 app.userInfoReadyCallback = res =&gt; { this.setData({ userInfo: res.userInfo, hasUserInfo: true }) } } else { // 在没有 open-type=getUserInfo 版本的兼容处理 wx.getUserInfo({ success: res =&gt; { app.globalData.userInfo = res.userInfo this.setData({ userInfo: res.userInfo, hasUserInfo: true }) } }) } }, getUserInfo: function(e) { console.log(e) app.globalData.userInfo = e.detail.userInfo this.setData({ userInfo: e.detail.userInfo, hasUserInfo: true }) } 整体效果 最后 这个小程序还有一些功能还没有实现，比如购物车，用户信息的保存在后台的问题，以后等自学完后端的一些知识，我还是得把这个小程序完整的做出来，喜欢的话大家可以关注我的github，我们可以一起学习，一起搞基哈，也希望可以给我提出一些宝贵的意见 源文件 期待你的star和fork第一次写文章，项目可能不是很好，表达的也未必清除，请给新手多一点的鼓励，点个赞，留下你的建议吧]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[独醉莫邪]]></title>
    <url>%2Fduzuimoye.github.io%2F2018%2F04%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[愿代码没有bug.假如生活欺骗了你，找程序员问问为什么编程；假如生活让你想死，找程序员问问Bug改完了没有；假如你觉得生活拮据，找程序员问问工资涨了没有；假如你觉得活着无聊，找程序员问问他们一天都干了什么…… To mysele花有重开日 人无再少年 Dreams希望今年能找到一份好工作 Motto新的一年，愿写码众生皆平等，男男女女皆欢喜。]]></content>
  </entry>
</search>
